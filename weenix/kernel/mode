./include/api/access.h:int copy_from_user(void *kaddr, const void *uaddr, size_t nbytes);
./include/api/binfmt.h:#include "fs/vnode.h"
./include/api/binfmt.h:typedef int(*binfmt_load_func_t)(const char *filename, int fd,
./include/api/binfmt.h:int  binfmt_add(const char *id, binfmt_load_func_t loadfunc);
./include/api/binfmt.h:int binfmt_load(const char *filename, char *const *argv, char *const *envp, uint32_t *eip, uint32_t *esp);
./include/api/elf.h:/* This file defines standard ELF types, structures, and macros.
./include/api/elf.h:   Copyright (C) 1995-2003, 2004 Free Software Foundation, Inc.
./include/api/elf.h:   This file is part of the GNU C Library.
./include/api/elf.h:   The GNU C Library is free software; you can redistribute it and/or
./include/api/elf.h:   modify it under the terms of the GNU Lesser General Public
./include/api/elf.h:   License as published by the Free Software Foundation; either
./include/api/elf.h:   version 2.1 of the License, or (at your option) any later version.
./include/api/elf.h:   The GNU C Library is distributed in the hope that it will be useful,
./include/api/elf.h:   but WITHOUT ANY WARRANTY; without even the implied warranty of
./include/api/elf.h:   Lesser General Public License for more details.
./include/api/elf.h:   You should have received a copy of the GNU Lesser General Public
./include/api/elf.h:   License along with the GNU C Library; if not, write to the Free
./include/api/elf.h:   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
./include/api/elf.h:#ifdef __KERNEL__
./include/api/elf.h:#endif
./include/api/elf.h:/* Type for a 16-bit quantity.  */
./include/api/elf.h:typedef uint16_t Elf32_Half;
./include/api/elf.h:typedef uint16_t Elf64_Half;
./include/api/elf.h:/* Types for signed and unsigned 32-bit quantities.  */
./include/api/elf.h:typedef uint32_t Elf32_Word;
./include/api/elf.h:typedef int32_t  Elf32_Sword;
./include/api/elf.h:typedef uint32_t Elf64_Word;
./include/api/elf.h:typedef int32_t  Elf64_Sword;
./include/api/elf.h:/* Types for signed and unsigned 64-bit quantities.  */
./include/api/elf.h:typedef uint64_t Elf32_Xword;
./include/api/elf.h:typedef int64_t  Elf32_Sxword;
./include/api/elf.h:typedef uint64_t Elf64_Xword;
./include/api/elf.h:typedef int64_t  Elf64_Sxword;
./include/api/elf.h:/* Type of addresses.  */
./include/api/elf.h:typedef uint32_t Elf32_Addr;
./include/api/elf.h:typedef uint64_t Elf64_Addr;
./include/api/elf.h:/* Type of file offsets.  */
./include/api/elf.h:typedef uint32_t Elf32_Off;
./include/api/elf.h:typedef uint64_t Elf64_Off;
./include/api/elf.h:/* Type for section indices, which are 16-bit quantities.  */
./include/api/elf.h:typedef uint16_t Elf32_Section;
./include/api/elf.h:typedef uint16_t Elf64_Section;
./include/api/elf.h:/* Type for version symbol information.  */
./include/api/elf.h:typedef Elf32_Half Elf32_Versym;
./include/api/elf.h:typedef Elf64_Half Elf64_Versym;
./include/api/elf.h:/* The ELF file header.  This appears at the start of every ELF file.  */
./include/api/elf.h:#define EI_NIDENT (16)
./include/api/elf.h:typedef struct {
./include/api/elf.h:        unsigned char e_ident[EI_NIDENT];     /* Magic number and other info */
./include/api/elf.h:        Elf32_Half    e_type;                 /* Object file type */
./include/api/elf.h:        Elf32_Half    e_machine;              /* Architecture */
./include/api/elf.h:        Elf32_Word    e_version;              /* Object file version */
./include/api/elf.h:        Elf32_Addr    e_entry;                /* Entry point virtual address */
./include/api/elf.h:        Elf32_Off     e_phoff;                /* Program header table file offset */
./include/api/elf.h:        Elf32_Off     e_shoff;                /* Section header table file offset */
./include/api/elf.h:        Elf32_Word    e_flags;                /* Processor-specific flags */
./include/api/elf.h:        Elf32_Half    e_ehsize;               /* ELF header size in bytes */
./include/api/elf.h:        Elf32_Half    e_phentsize;            /* Program header table entry size */
./include/api/elf.h:        Elf32_Half    e_phnum;                /* Program header table entry count */
./include/api/elf.h:        Elf32_Half    e_shentsize;            /* Section header table entry size */
./include/api/elf.h:        Elf32_Half    e_shnum;                /* Section header table entry count */
./include/api/elf.h:        Elf32_Half    e_shstrndx;             /* Section header string table index */
./include/api/elf.h:} Elf32_Ehdr;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        unsigned char e_ident[EI_NIDENT];     /* Magic number and other info */
./include/api/elf.h:        Elf64_Half    e_type;                 /* Object file type */
./include/api/elf.h:        Elf64_Half    e_machine;              /* Architecture */
./include/api/elf.h:        Elf64_Word    e_version;              /* Object file version */
./include/api/elf.h:        Elf64_Addr    e_entry;                /* Entry point virtual address */
./include/api/elf.h:        Elf64_Off     e_phoff;                /* Program header table file offset */
./include/api/elf.h:        Elf64_Off     e_shoff;                /* Section header table file offset */
./include/api/elf.h:        Elf64_Word    e_flags;                /* Processor-specific flags */
./include/api/elf.h:        Elf64_Half    e_ehsize;               /* ELF header size in bytes */
./include/api/elf.h:        Elf64_Half    e_phentsize;            /* Program header table entry size */
./include/api/elf.h:        Elf64_Half    e_phnum;                /* Program header table entry count */
./include/api/elf.h:        Elf64_Half    e_shentsize;            /* Section header table entry size */
./include/api/elf.h:        Elf64_Half    e_shnum;                /* Section header table entry count */
./include/api/elf.h:        Elf64_Half    e_shstrndx;             /* Section header string table index */
./include/api/elf.h:} Elf64_Ehdr;
./include/api/elf.h:#define EI_MAG0         0               /* File identification byte 0 index */
./include/api/elf.h:#define ELFMAG0         0x7f            /* Magic number byte 0 */
./include/api/elf.h:#define EI_MAG1         1               /* File identification byte 1 index */
./include/api/elf.h:#define ELFMAG1         'E'             /* Magic number byte 1 */
./include/api/elf.h:#define EI_MAG2         2               /* File identification byte 2 index */
./include/api/elf.h:#define ELFMAG2         'L'             /* Magic number byte 2 */
./include/api/elf.h:#define EI_MAG3         3               /* File identification byte 3 index */
./include/api/elf.h:#define ELFMAG3         'F'             /* Magic number byte 3 */
./include/api/elf.h:/* Conglomeration of the identification bytes, for easy testing as a word.  */
./include/api/elf.h:#define ELFMAG          "\177ELF"
./include/api/elf.h:#define SELFMAG         4
./include/api/elf.h:#define EI_CLASS        4               /* File class byte index */
./include/api/elf.h:#define ELFCLASSNONE    0               /* Invalid class */
./include/api/elf.h:#define ELFCLASS32      1               /* 32-bit objects */
./include/api/elf.h:#define ELFCLASS64      2               /* 64-bit objects */
./include/api/elf.h:#define ELFCLASSNUM     3
./include/api/elf.h:#define EI_DATA         5               /* Data encoding byte index */
./include/api/elf.h:#define ELFDATANONE     0               /* Invalid data encoding */
./include/api/elf.h:#define ELFDATA2LSB     1               /* 2's complement, little endian */
./include/api/elf.h:#define ELFDATA2MSB     2               /* 2's complement, big endian */
./include/api/elf.h:#define ELFDATANUM      3
./include/api/elf.h:#define EI_VERSION      6               /* File version byte index */
./include/api/elf.h:#define EI_OSABI        7               /* OS ABI identification */
./include/api/elf.h:#define ELFOSABI_NONE           0       /* UNIX System V ABI */
./include/api/elf.h:#define ELFOSABI_SYSV           0       /* Alias.  */
./include/api/elf.h:#define ELFOSABI_HPUX           1       /* HP-UX */
./include/api/elf.h:#define ELFOSABI_NETBSD         2       /* NetBSD.  */
./include/api/elf.h:#define ELFOSABI_LINUX          3       /* Linux.  */
./include/api/elf.h:#define ELFOSABI_SOLARIS        6       /* Sun Solaris.  */
./include/api/elf.h:#define ELFOSABI_AIX            7       /* IBM AIX.  */
./include/api/elf.h:#define ELFOSABI_IRIX           8       /* SGI Irix.  */
./include/api/elf.h:#define ELFOSABI_FREEBSD        9       /* FreeBSD.  */
./include/api/elf.h:#define ELFOSABI_TRU64          10      /* Compaq TRU64 UNIX.  */
./include/api/elf.h:#define ELFOSABI_MODESTO        11      /* Novell Modesto.  */
./include/api/elf.h:#define ELFOSABI_OPENBSD        12      /* OpenBSD.  */
./include/api/elf.h:#define ELFOSABI_ARM            97      /* ARM */
./include/api/elf.h:#define ELFOSABI_STANDALONE     255     /* Standalone (embedded) application */
./include/api/elf.h:#define EI_ABIVERSION   8               /* ABI version */
./include/api/elf.h:#define EI_PAD          9               /* Byte index of padding bytes */
./include/api/elf.h:/* Legal values for e_type (object file type).  */
./include/api/elf.h:#define ET_NONE         0               /* No file type */
./include/api/elf.h:#define ET_REL          1               /* Relocatable file */
./include/api/elf.h:#define ET_EXEC         2               /* Executable file */
./include/api/elf.h:#define ET_DYN          3               /* Shared object file */
./include/api/elf.h:#define ET_CORE         4               /* Core file */
./include/api/elf.h:#define ET_NUM          5               /* Number of defined types */
./include/api/elf.h:#define ET_LOOS         0xfe00          /* OS-specific range start */
./include/api/elf.h:#define ET_HIOS         0xfeff          /* OS-specific range end */
./include/api/elf.h:#define ET_LOPROC       0xff00          /* Processor-specific range start */
./include/api/elf.h:#define ET_HIPROC       0xffff          /* Processor-specific range end */
./include/api/elf.h:/* Legal values for e_machine (architecture).  */
./include/api/elf.h:#define EM_NONE          0              /* No machine */
./include/api/elf.h:#define EM_M32           1              /* AT&T WE 32100 */
./include/api/elf.h:#define EM_SPARC         2              /* SUN SPARC */
./include/api/elf.h:#define EM_386           3              /* Intel 80386 */
./include/api/elf.h:#define EM_68K           4              /* Motorola m68k family */
./include/api/elf.h:#define EM_88K           5              /* Motorola m88k family */
./include/api/elf.h:#define EM_860           7              /* Intel 80860 */
./include/api/elf.h:#define EM_MIPS          8              /* MIPS R3000 big-endian */
./include/api/elf.h:#define EM_S370          9              /* IBM System/370 */
./include/api/elf.h:#define EM_MIPS_RS3_LE  10              /* MIPS R3000 little-endian */
./include/api/elf.h:#define EM_PARISC       15              /* HPPA */
./include/api/elf.h:#define EM_VPP500       17              /* Fujitsu VPP500 */
./include/api/elf.h:#define EM_SPARC32PLUS  18              /* Sun's "v8plus" */
./include/api/elf.h:#define EM_960          19              /* Intel 80960 */
./include/api/elf.h:#define EM_PPC          20              /* PowerPC */
./include/api/elf.h:#define EM_PPC64        21              /* PowerPC 64-bit */
./include/api/elf.h:#define EM_S390         22              /* IBM S390 */
./include/api/elf.h:#define EM_V800         36              /* NEC V800 series */
./include/api/elf.h:#define EM_FR20         37              /* Fujitsu FR20 */
./include/api/elf.h:#define EM_RH32         38              /* TRW RH-32 */
./include/api/elf.h:#define EM_RCE          39              /* Motorola RCE */
./include/api/elf.h:#define EM_ARM          40              /* ARM */
./include/api/elf.h:#define EM_FAKE_ALPHA   41              /* Digital Alpha */
./include/api/elf.h:#define EM_SH           42              /* Hitachi SH */
./include/api/elf.h:#define EM_SPARCV9      43              /* SPARC v9 64-bit */
./include/api/elf.h:#define EM_TRICORE      44              /* Siemens Tricore */
./include/api/elf.h:#define EM_ARC          45              /* Argonaut RISC Core */
./include/api/elf.h:#define EM_H8_300       46              /* Hitachi H8/300 */
./include/api/elf.h:#define EM_H8_300H      47              /* Hitachi H8/300H */
./include/api/elf.h:#define EM_H8S          48              /* Hitachi H8S */
./include/api/elf.h:#define EM_H8_500       49              /* Hitachi H8/500 */
./include/api/elf.h:#define EM_IA_64        50              /* Intel Merced */
./include/api/elf.h:#define EM_MIPS_X       51              /* Stanford MIPS-X */
./include/api/elf.h:#define EM_COLDFIRE     52              /* Motorola Coldfire */
./include/api/elf.h:#define EM_68HC12       53              /* Motorola M68HC12 */
./include/api/elf.h:#define EM_MMA          54              /* Fujitsu MMA Multimedia Accelerator*/
./include/api/elf.h:#define EM_PCP          55              /* Siemens PCP */
./include/api/elf.h:#define EM_NCPU         56              /* Sony nCPU embeeded RISC */
./include/api/elf.h:#define EM_NDR1         57              /* Denso NDR1 microprocessor */
./include/api/elf.h:#define EM_STARCORE     58              /* Motorola Start*Core processor */
./include/api/elf.h:#define EM_ME16         59              /* Toyota ME16 processor */
./include/api/elf.h:#define EM_ST100        60              /* STMicroelectronic ST100 processor */
./include/api/elf.h:#define EM_TINYJ        61              /* Advanced Logic Corp. Tinyj emb.fam*/
./include/api/elf.h:#define EM_X86_64       62              /* AMD x86-64 architecture */
./include/api/elf.h:#define EM_PDSP         63              /* Sony DSP Processor */
./include/api/elf.h:#define EM_FX66         66              /* Siemens FX66 microcontroller */
./include/api/elf.h:#define EM_ST9PLUS      67              /* STMicroelectronics ST9+ 8/16 mc */
./include/api/elf.h:#define EM_ST7          68              /* STmicroelectronics ST7 8 bit mc */
./include/api/elf.h:#define EM_68HC16       69              /* Motorola MC68HC16 microcontroller */
./include/api/elf.h:#define EM_68HC11       70              /* Motorola MC68HC11 microcontroller */
./include/api/elf.h:#define EM_68HC08       71              /* Motorola MC68HC08 microcontroller */
./include/api/elf.h:#define EM_68HC05       72              /* Motorola MC68HC05 microcontroller */
./include/api/elf.h:#define EM_SVX          73              /* Silicon Graphics SVx */
./include/api/elf.h:#define EM_ST19         74              /* STMicroelectronics ST19 8 bit mc */
./include/api/elf.h:#define EM_VAX          75              /* Digital VAX */
./include/api/elf.h:#define EM_CRIS         76              /* Axis Communications 32-bit embedded processor */
./include/api/elf.h:#define EM_JAVELIN      77              /* Infineon Technologies 32-bit embedded processor */
./include/api/elf.h:#define EM_FIREPATH     78              /* Element 14 64-bit DSP Processor */
./include/api/elf.h:#define EM_ZSP          79              /* LSI Logic 16-bit DSP Processor */
./include/api/elf.h:#define EM_MMIX         80              /* Donald Knuth's educational 64-bit processor */
./include/api/elf.h:#define EM_HUANY        81              /* Harvard University machine-independent object files */
./include/api/elf.h:#define EM_PRISM        82              /* SiTera Prism */
./include/api/elf.h:#define EM_AVR          83              /* Atmel AVR 8-bit microcontroller */
./include/api/elf.h:#define EM_FR30         84              /* Fujitsu FR30 */
./include/api/elf.h:#define EM_D10V         85              /* Mitsubishi D10V */
./include/api/elf.h:#define EM_D30V         86              /* Mitsubishi D30V */
./include/api/elf.h:#define EM_V850         87              /* NEC v850 */
./include/api/elf.h:#define EM_M32R         88              /* Mitsubishi M32R */
./include/api/elf.h:#define EM_MN10300      89              /* Matsushita MN10300 */
./include/api/elf.h:#define EM_MN10200      90              /* Matsushita MN10200 */
./include/api/elf.h:#define EM_PJ           91              /* picoJava */
./include/api/elf.h:#define EM_OPENRISC     92              /* OpenRISC 32-bit embedded processor */
./include/api/elf.h:#define EM_ARC_A5       93              /* ARC Cores Tangent-A5 */
./include/api/elf.h:#define EM_XTENSA       94              /* Tensilica Xtensa Architecture */
./include/api/elf.h:#define EM_NUM          95
./include/api/elf.h:/* If it is necessary to assign new unofficial EM_* values, please
./include/api/elf.h:   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
./include/api/elf.h:   chances of collision with official or non-GNU unofficial values.  */
./include/api/elf.h:#define EM_ALPHA        0x9026
./include/api/elf.h:/* Legal values for e_version (version).  */
./include/api/elf.h:#define EV_NONE         0               /* Invalid ELF version */
./include/api/elf.h:#define EV_CURRENT      1               /* Current version */
./include/api/elf.h:#define EV_NUM          2
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    sh_name;                /* Section name (string tbl index) */
./include/api/elf.h:        Elf32_Word    sh_type;                /* Section type */
./include/api/elf.h:        Elf32_Word    sh_flags;               /* Section flags */
./include/api/elf.h:        Elf32_Addr    sh_addr;                /* Section virtual addr at execution */
./include/api/elf.h:        Elf32_Off     sh_offset;              /* Section file offset */
./include/api/elf.h:        Elf32_Word    sh_size;                /* Section size in bytes */
./include/api/elf.h:        Elf32_Word    sh_link;                /* Link to another section */
./include/api/elf.h:        Elf32_Word    sh_info;                /* Additional section information */
./include/api/elf.h:        Elf32_Word    sh_addralign;           /* Section alignment */
./include/api/elf.h:        Elf32_Word    sh_entsize;             /* Entry size if section holds table */
./include/api/elf.h:} Elf32_Shdr;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word    sh_name;                /* Section name (string tbl index) */
./include/api/elf.h:        Elf64_Word    sh_type;                /* Section type */
./include/api/elf.h:        Elf64_Xword   sh_flags;               /* Section flags */
./include/api/elf.h:        Elf64_Addr    sh_addr;                /* Section virtual addr at execution */
./include/api/elf.h:        Elf64_Off     sh_offset;              /* Section file offset */
./include/api/elf.h:        Elf64_Xword   sh_size;                /* Section size in bytes */
./include/api/elf.h:        Elf64_Word    sh_link;                /* Link to another section */
./include/api/elf.h:        Elf64_Word    sh_info;                /* Additional section information */
./include/api/elf.h:        Elf64_Xword   sh_addralign;           /* Section alignment */
./include/api/elf.h:        Elf64_Xword   sh_entsize;             /* Entry size if section holds table */
./include/api/elf.h:} Elf64_Shdr;
./include/api/elf.h:#define SHN_UNDEF       0               /* Undefined section */
./include/api/elf.h:#define SHN_LORESERVE   0xff00          /* Start of reserved indices */
./include/api/elf.h:#define SHN_LOPROC      0xff00          /* Start of processor-specific */
./include/api/elf.h:#define SHN_BEFORE      0xff00          /* Order section before all others
./include/api/elf.h:#define SHN_AFTER       0xff01          /* Order section after all others
./include/api/elf.h:#define SHN_HIPROC      0xff1f          /* End of processor-specific */
./include/api/elf.h:#define SHN_LOOS        0xff20          /* Start of OS-specific */
./include/api/elf.h:#define SHN_HIOS        0xff3f          /* End of OS-specific */
./include/api/elf.h:#define SHN_ABS         0xfff1          /* Associated symbol is absolute */
./include/api/elf.h:#define SHN_COMMON      0xfff2          /* Associated symbol is common */
./include/api/elf.h:#define SHN_XINDEX      0xffff          /* Index is in extra table.  */
./include/api/elf.h:#define SHN_HIRESERVE   0xffff          /* End of reserved indices */
./include/api/elf.h:/* Legal values for sh_type (section type).  */
./include/api/elf.h:#define SHT_NULL          0             /* Section header table entry unused */
./include/api/elf.h:#define SHT_PROGBITS      1             /* Program data */
./include/api/elf.h:#define SHT_SYMTAB        2             /* Symbol table */
./include/api/elf.h:#define SHT_STRTAB        3             /* String table */
./include/api/elf.h:#define SHT_RELA          4             /* Relocation entries with addends */
./include/api/elf.h:#define SHT_HASH          5             /* Symbol hash table */
./include/api/elf.h:#define SHT_DYNAMIC       6             /* Dynamic linking information */
./include/api/elf.h:#define SHT_NOTE          7             /* Notes */
./include/api/elf.h:#define SHT_NOBITS        8             /* Program space with no data (bss) */
./include/api/elf.h:#define SHT_REL           9             /* Relocation entries, no addends */
./include/api/elf.h:#define SHT_SHLIB         10            /* Reserved */
./include/api/elf.h:#define SHT_DYNSYM        11            /* Dynamic linker symbol table */
./include/api/elf.h:#define SHT_INIT_ARRAY    14            /* Array of constructors */
./include/api/elf.h:#define SHT_FINI_ARRAY    15            /* Array of destructors */
./include/api/elf.h:#define SHT_PREINIT_ARRAY 16            /* Array of pre-constructors */
./include/api/elf.h:#define SHT_GROUP         17            /* Section group */
./include/api/elf.h:#define SHT_SYMTAB_SHNDX  18            /* Extended section indeces */
./include/api/elf.h:#define SHT_NUM           19            /* Number of defined types.  */
./include/api/elf.h:#define SHT_LOOS          0x60000000    /* Start OS-specific */
./include/api/elf.h:#define SHT_GNU_LIBLIST   0x6ffffff7    /* Prelink library list */
./include/api/elf.h:#define SHT_CHECKSUM      0x6ffffff8    /* Checksum for DSO content.  */
./include/api/elf.h:#define SHT_LOSUNW        0x6ffffffa    /* Sun-specific low bound.  */
./include/api/elf.h:#define SHT_SUNW_move     0x6ffffffa
./include/api/elf.h:#define SHT_SUNW_COMDAT   0x6ffffffb
./include/api/elf.h:#define SHT_SUNW_syminfo  0x6ffffffc
./include/api/elf.h:#define SHT_GNU_verdef    0x6ffffffd    /* Version definition section.  */
./include/api/elf.h:#define SHT_GNU_verneed   0x6ffffffe    /* Version needs section.  */
./include/api/elf.h:#define SHT_GNU_versym    0x6fffffff    /* Version symbol table.  */
./include/api/elf.h:#define SHT_HISUNW        0x6fffffff    /* Sun-specific high bound.  */
./include/api/elf.h:#define SHT_HIOS          0x6fffffff    /* End OS-specific type */
./include/api/elf.h:#define SHT_LOPROC        0x70000000    /* Start of processor-specific */
./include/api/elf.h:#define SHT_HIPROC        0x7fffffff    /* End of processor-specific */
./include/api/elf.h:#define SHT_LOUSER        0x80000000    /* Start of application-specific */
./include/api/elf.h:#define SHT_HIUSER        0x8fffffff    /* End of application-specific */
./include/api/elf.h:/* Legal values for sh_flags (section flags).  */
./include/api/elf.h:#define SHF_WRITE            (1 << 0)   /* Writable */
./include/api/elf.h:#define SHF_ALLOC            (1 << 1)   /* Occupies memory during execution */
./include/api/elf.h:#define SHF_EXECINSTR        (1 << 2)   /* Executable */
./include/api/elf.h:#define SHF_MERGE            (1 << 4)   /* Might be merged */
./include/api/elf.h:#define SHF_STRINGS          (1 << 5)   /* Contains nul-terminated strings */
./include/api/elf.h:#define SHF_INFO_LINK        (1 << 6)   /* `sh_info' contains SHT index */
./include/api/elf.h:#define SHF_LINK_ORDER       (1 << 7)   /* Preserve order after combining */
./include/api/elf.h:#define SHF_OS_NONCONFORMING (1 << 8)   /* Non-standard OS specific handling
./include/api/elf.h:#define SHF_GROUP            (1 << 9)   /* Section is member of a group.  */
./include/api/elf.h:#define SHF_TLS              (1 << 10)  /* Section hold thread-local data.  */
./include/api/elf.h:#define SHF_MASKOS           0x0ff00000 /* OS-specific.  */
./include/api/elf.h:#define SHF_MASKPROC         0xf0000000 /* Processor-specific */
./include/api/elf.h:#define SHF_ORDERED          (1 << 30)  /* Special ordering requirement
./include/api/elf.h:#define SHF_EXCLUDE          (1 << 31)  /* Section is excluded unless
./include/api/elf.h:referenced or allocated (Solaris).*/
./include/api/elf.h:#define GRP_COMDAT      0x1             /* Mark group as COMDAT.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    st_name;                /* Symbol name (string tbl index) */
./include/api/elf.h:        Elf32_Addr    st_value;               /* Symbol value */
./include/api/elf.h:        Elf32_Word    st_size;                /* Symbol size */
./include/api/elf.h:        unsigned char st_info;                /* Symbol type and binding */
./include/api/elf.h:        Elf32_Section st_shndx;               /* Section index */
./include/api/elf.h:} Elf32_Sym;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word    st_name;                /* Symbol name (string tbl index) */
./include/api/elf.h:        unsigned char st_info;                /* Symbol type and binding */
./include/api/elf.h:        Elf64_Section st_shndx;               /* Section index */
./include/api/elf.h:        Elf64_Addr    st_value;               /* Symbol value */
./include/api/elf.h:        Elf64_Xword   st_size;                /* Symbol size */
./include/api/elf.h:} Elf64_Sym;
./include/api/elf.h:/* The syminfo section if available contains additional information about
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Half si_boundto;                /* Direct bindings, symbol bound to */
./include/api/elf.h:        Elf32_Half si_flags;                  /* Per symbol flags */
./include/api/elf.h:} Elf32_Syminfo;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Half si_boundto;                /* Direct bindings, symbol bound to */
./include/api/elf.h:        Elf64_Half si_flags;                  /* Per symbol flags */
./include/api/elf.h:} Elf64_Syminfo;
./include/api/elf.h:/* Possible values for si_boundto.  */
./include/api/elf.h:#define SYMINFO_BT_SELF         0xffff  /* Symbol bound to self */
./include/api/elf.h:#define SYMINFO_BT_PARENT       0xfffe  /* Symbol bound to parent */
./include/api/elf.h:#define SYMINFO_BT_LOWRESERVE   0xff00  /* Beginning of reserved entries */
./include/api/elf.h:/* Possible bitmasks for si_flags.  */
./include/api/elf.h:#define SYMINFO_FLG_DIRECT      0x0001  /* Direct bound symbol */
./include/api/elf.h:#define SYMINFO_FLG_PASSTHRU    0x0002  /* Pass-thru symbol for translator */
./include/api/elf.h:#define SYMINFO_FLG_COPY        0x0004  /* Symbol is a copy-reloc */
./include/api/elf.h:#define SYMINFO_FLG_LAZYLOAD    0x0008  /* Symbol bound to object to be lazy loaded */
./include/api/elf.h:/* Syminfo version values.  */
./include/api/elf.h:#define SYMINFO_NONE            0
./include/api/elf.h:#define SYMINFO_CURRENT         1
./include/api/elf.h:#define SYMINFO_NUM             2
./include/api/elf.h:/* How to extract and insert information held in the st_info field.  */
./include/api/elf.h:#define ELF32_ST_BIND(val)              (((unsigned char) (val)) >> 4)
./include/api/elf.h:#define ELF32_ST_TYPE(val)              ((val) & 0xf)
./include/api/elf.h:#define ELF32_ST_INFO(bind, type)       (((bind) << 4) + ((type) & 0xf))
./include/api/elf.h:/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
./include/api/elf.h:#define ELF64_ST_BIND(val)              ELF32_ST_BIND (val)
./include/api/elf.h:#define ELF64_ST_TYPE(val)              ELF32_ST_TYPE (val)
./include/api/elf.h:#define ELF64_ST_INFO(bind, type)       ELF32_ST_INFO ((bind), (type))
./include/api/elf.h:/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
./include/api/elf.h:#define STB_LOCAL       0               /* Local symbol */
./include/api/elf.h:#define STB_GLOBAL      1               /* Global symbol */
./include/api/elf.h:#define STB_WEAK        2               /* Weak symbol */
./include/api/elf.h:#define STB_NUM         3               /* Number of defined types.  */
./include/api/elf.h:#define STB_LOOS        10              /* Start of OS-specific */
./include/api/elf.h:#define STB_HIOS        12              /* End of OS-specific */
./include/api/elf.h:#define STB_LOPROC      13              /* Start of processor-specific */
./include/api/elf.h:#define STB_HIPROC      15              /* End of processor-specific */
./include/api/elf.h:/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
./include/api/elf.h:#define STT_NOTYPE      0               /* Symbol type is unspecified */
./include/api/elf.h:#define STT_OBJECT      1               /* Symbol is a data object */
./include/api/elf.h:#define STT_FUNC        2               /* Symbol is a code object */
./include/api/elf.h:#define STT_SECTION     3               /* Symbol associated with a section */
./include/api/elf.h:#define STT_FILE        4               /* Symbol's name is file name */
./include/api/elf.h:#define STT_COMMON      5               /* Symbol is a common data object */
./include/api/elf.h:#define STT_TLS         6               /* Symbol is thread-local data object*/
./include/api/elf.h:#define STT_NUM         7               /* Number of defined types.  */
./include/api/elf.h:#define STT_LOOS        10              /* Start of OS-specific */
./include/api/elf.h:#define STT_HIOS        12              /* End of OS-specific */
./include/api/elf.h:#define STT_LOPROC      13              /* Start of processor-specific */
./include/api/elf.h:#define STT_HIPROC      15              /* End of processor-specific */
./include/api/elf.h:/* Symbol table indices are found in the hash buckets and chain table
./include/api/elf.h:   of a symbol hash table section.  This special index value indicates
./include/api/elf.h:   the end of a chain, meaning no further symbols are found in that bucket.  */
./include/api/elf.h:#define STN_UNDEF       0               /* End of a chain.  */
./include/api/elf.h:/* How to extract and insert information held in the st_other field.  */
./include/api/elf.h:#define ELF32_ST_VISIBILITY(o)  ((o) & 0x03)
./include/api/elf.h:/* For ELF64 the definitions are the same.  */
./include/api/elf.h:#define ELF64_ST_VISIBILITY(o)  ELF32_ST_VISIBILITY (o)
./include/api/elf.h:/* Symbol visibility specification encoded in the st_other field.  */
./include/api/elf.h:#define STV_DEFAULT     0               /* Default symbol visibility rules */
./include/api/elf.h:#define STV_INTERNAL    1               /* Processor specific hidden class */
./include/api/elf.h:#define STV_HIDDEN      2               /* Sym unavailable in other modules */
./include/api/elf.h:#define STV_PROTECTED   3               /* Not preemptible, not exported */
./include/api/elf.h:/* Relocation table entry without addend (in section of type SHT_REL).  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Addr    r_offset;               /* Address */
./include/api/elf.h:        Elf32_Word    r_info;                 /* Relocation type and symbol index */
./include/api/elf.h:} Elf32_Rel;
./include/api/elf.h:/* I have seen two different definitions of the Elf64_Rel and
./include/api/elf.h:   Elf64_Rela structures, so we'll leave them out until Novell (or
./include/api/elf.h:/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Addr    r_offset;               /* Address */
./include/api/elf.h:        Elf64_Xword   r_info;                 /* Relocation type and symbol index */
./include/api/elf.h:} Elf64_Rel;
./include/api/elf.h:/* Relocation table entry with addend (in section of type SHT_RELA).  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Addr    r_offset;               /* Address */
./include/api/elf.h:        Elf32_Word    r_info;                 /* Relocation type and symbol index */
./include/api/elf.h:        Elf32_Sword   r_addend;               /* Addend */
./include/api/elf.h:} Elf32_Rela;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Addr    r_offset;               /* Address */
./include/api/elf.h:        Elf64_Xword   r_info;                 /* Relocation type and symbol index */
./include/api/elf.h:        Elf64_Sxword  r_addend;               /* Addend */
./include/api/elf.h:} Elf64_Rela;
./include/api/elf.h:/* How to extract and insert information held in the r_info field.  */
./include/api/elf.h:#define ELF32_R_SYM(val)                ((val) >> 8)
./include/api/elf.h:#define ELF32_R_TYPE(val)               ((val) & 0xff)
./include/api/elf.h:#define ELF32_R_INFO(sym, type)         (((sym) << 8) + ((type) & 0xff))
./include/api/elf.h:#define ELF64_R_SYM(i)                  ((i) >> 32)
./include/api/elf.h:#define ELF64_R_TYPE(i)                 ((i) & 0xffffffff)
./include/api/elf.h:#define ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) << 32) + (type))
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    p_type;                 /* Segment type */
./include/api/elf.h:        Elf32_Off     p_offset;               /* Segment file offset */
./include/api/elf.h:        Elf32_Addr    p_vaddr;                /* Segment virtual address */
./include/api/elf.h:        Elf32_Addr    p_paddr;                /* Segment physical address */
./include/api/elf.h:        Elf32_Word    p_filesz;               /* Segment size in file */
./include/api/elf.h:        Elf32_Word    p_memsz;                /* Segment size in memory */
./include/api/elf.h:        Elf32_Word    p_flags;                /* Segment flags */
./include/api/elf.h:        Elf32_Word    p_align;                /* Segment alignment */
./include/api/elf.h:} Elf32_Phdr;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word    p_type;                 /* Segment type */
./include/api/elf.h:        Elf64_Word    p_flags;                /* Segment flags */
./include/api/elf.h:        Elf64_Off     p_offset;               /* Segment file offset */
./include/api/elf.h:        Elf64_Addr    p_vaddr;                /* Segment virtual address */
./include/api/elf.h:        Elf64_Addr    p_paddr;                /* Segment physical address */
./include/api/elf.h:        Elf64_Xword   p_filesz;               /* Segment size in file */
./include/api/elf.h:        Elf64_Xword   p_memsz;                /* Segment size in memory */
./include/api/elf.h:        Elf64_Xword   p_align;                /* Segment alignment */
./include/api/elf.h:} Elf64_Phdr;
./include/api/elf.h:/* Legal values for p_type (segment type).  */
./include/api/elf.h:#define PT_NULL         0               /* Program header table entry unused */
./include/api/elf.h:#define PT_LOAD         1               /* Loadable program segment */
./include/api/elf.h:#define PT_DYNAMIC      2               /* Dynamic linking information */
./include/api/elf.h:#define PT_INTERP       3               /* Program interpreter */
./include/api/elf.h:#define PT_NOTE         4               /* Auxiliary information */
./include/api/elf.h:#define PT_SHLIB        5               /* Reserved */
./include/api/elf.h:#define PT_PHDR         6               /* Entry for header table itself */
./include/api/elf.h:#define PT_TLS          7               /* Thread-local storage segment */
./include/api/elf.h:#define PT_NUM          8               /* Number of defined types */
./include/api/elf.h:#define PT_LOOS         0x60000000      /* Start of OS-specific */
./include/api/elf.h:#define PT_GNU_EH_FRAME 0x6474e550      /* GCC .eh_frame_hdr segment */
./include/api/elf.h:#define PT_GNU_STACK    0x6474e551      /* Indicates stack executability */
./include/api/elf.h:#define PT_GNU_RELRO    0x6474e552      /* Read-only after relocation */
./include/api/elf.h:#define PT_LOSUNW       0x6ffffffa
./include/api/elf.h:#define PT_SUNWBSS      0x6ffffffa      /* Sun Specific segment */
./include/api/elf.h:#define PT_SUNWSTACK    0x6ffffffb      /* Stack segment */
./include/api/elf.h:#define PT_HISUNW       0x6fffffff
./include/api/elf.h:#define PT_HIOS         0x6fffffff      /* End of OS-specific */
./include/api/elf.h:#define PT_LOPROC       0x70000000      /* Start of processor-specific */
./include/api/elf.h:#define PT_HIPROC       0x7fffffff      /* End of processor-specific */
./include/api/elf.h:/* Legal values for p_flags (segment flags).  */
./include/api/elf.h:#define PF_X            (1 << 0)        /* Segment is executable */
./include/api/elf.h:#define PF_W            (1 << 1)        /* Segment is writable */
./include/api/elf.h:#define PF_R            (1 << 2)        /* Segment is readable */
./include/api/elf.h:#define PF_MASKOS       0x0ff00000      /* OS-specific */
./include/api/elf.h:#define PF_MASKPROC     0xf0000000      /* Processor-specific */
./include/api/elf.h:/* Legal values for note segment descriptor types for core files. */
./include/api/elf.h:#define NT_PRSTATUS     1               /* Contains copy of prstatus struct */
./include/api/elf.h:#define NT_FPREGSET     2               /* Contains copy of fpregset struct */
./include/api/elf.h:#define NT_PRPSINFO     3               /* Contains copy of prpsinfo struct */
./include/api/elf.h:#define NT_PRXREG       4               /* Contains copy of prxregset struct */
./include/api/elf.h:#define NT_TASKSTRUCT   4               /* Contains copy of task structure */
./include/api/elf.h:#define NT_PLATFORM     5               /* String from sysinfo(SI_PLATFORM) */
./include/api/elf.h:#define NT_AUXV         6               /* Contains copy of auxv array */
./include/api/elf.h:#define NT_GWINDOWS     7               /* Contains copy of gwindows struct */
./include/api/elf.h:#define NT_ASRS         8               /* Contains copy of asrset struct */
./include/api/elf.h:#define NT_PSTATUS      10              /* Contains copy of pstatus struct */
./include/api/elf.h:#define NT_PSINFO       13              /* Contains copy of psinfo struct */
./include/api/elf.h:#define NT_PRCRED       14              /* Contains copy of prcred struct */
./include/api/elf.h:#define NT_UTSNAME      15              /* Contains copy of utsname struct */
./include/api/elf.h:#define NT_LWPSTATUS    16              /* Contains copy of lwpstatus struct */
./include/api/elf.h:#define NT_LWPSINFO     17              /* Contains copy of lwpinfo struct */
./include/api/elf.h:#define NT_PRFPXREG     20              /* Contains copy of fprxregset struct*/
./include/api/elf.h:/* Legal values for the note segment descriptor types for object files.  */
./include/api/elf.h:#define NT_VERSION      1               /* Contains a version string.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Sword   d_tag;                  /* Dynamic entry type */
./include/api/elf.h:                Elf32_Word d_val;                 /* Integer value */
./include/api/elf.h:                Elf32_Addr d_ptr;                 /* Address value */
./include/api/elf.h:} Elf32_Dyn;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Sxword  d_tag;                  /* Dynamic entry type */
./include/api/elf.h:                Elf64_Xword d_val;                /* Integer value */
./include/api/elf.h:                Elf64_Addr d_ptr;                 /* Address value */
./include/api/elf.h:} Elf64_Dyn;
./include/api/elf.h:/* Legal values for d_tag (dynamic entry type).  */
./include/api/elf.h:#define DT_NULL         0               /* Marks end of dynamic section */
./include/api/elf.h:#define DT_NEEDED       1               /* Name of needed library */
./include/api/elf.h:#define DT_PLTRELSZ     2               /* Size in bytes of PLT relocs */
./include/api/elf.h:#define DT_PLTGOT       3               /* Processor defined value */
./include/api/elf.h:#define DT_HASH         4               /* Address of symbol hash table */
./include/api/elf.h:#define DT_STRTAB       5               /* Address of string table */
./include/api/elf.h:#define DT_SYMTAB       6               /* Address of symbol table */
./include/api/elf.h:#define DT_RELA         7               /* Address of Rela relocs */
./include/api/elf.h:#define DT_RELASZ       8               /* Total size of Rela relocs */
./include/api/elf.h:#define DT_RELAENT      9               /* Size of one Rela reloc */
./include/api/elf.h:#define DT_STRSZ        10              /* Size of string table */
./include/api/elf.h:#define DT_SYMENT       11              /* Size of one symbol table entry */
./include/api/elf.h:#define DT_INIT         12              /* Address of init function */
./include/api/elf.h:#define DT_FINI         13              /* Address of termination function */
./include/api/elf.h:#define DT_SONAME       14              /* Name of shared object */
./include/api/elf.h:#define DT_RPATH        15              /* Library search path (deprecated) */
./include/api/elf.h:#define DT_SYMBOLIC     16              /* Start symbol search here */
./include/api/elf.h:#define DT_REL          17              /* Address of Rel relocs */
./include/api/elf.h:#define DT_RELSZ        18              /* Total size of Rel relocs */
./include/api/elf.h:#define DT_RELENT       19              /* Size of one Rel reloc */
./include/api/elf.h:#define DT_PLTREL       20              /* Type of reloc in PLT */
./include/api/elf.h:#define DT_DEBUG        21              /* For debugging; unspecified */
./include/api/elf.h:#define DT_TEXTREL      22              /* Reloc might modify .text */
./include/api/elf.h:#define DT_JMPREL       23              /* Address of PLT relocs */
./include/api/elf.h:#define DT_BIND_NOW     24              /* Process relocations of object */
./include/api/elf.h:#define DT_INIT_ARRAY   25              /* Array with addresses of init fct */
./include/api/elf.h:#define DT_FINI_ARRAY   26              /* Array with addresses of fini fct */
./include/api/elf.h:#define DT_INIT_ARRAYSZ 27              /* Size in bytes of DT_INIT_ARRAY */
./include/api/elf.h:#define DT_FINI_ARRAYSZ 28              /* Size in bytes of DT_FINI_ARRAY */
./include/api/elf.h:#define DT_RUNPATH      29              /* Library search path */
./include/api/elf.h:#define DT_FLAGS        30              /* Flags for the object being loaded */
./include/api/elf.h:#define DT_ENCODING     32              /* Start of encoded range */
./include/api/elf.h:#define DT_PREINIT_ARRAY 32             /* Array with addresses of preinit fct*/
./include/api/elf.h:#define DT_PREINIT_ARRAYSZ 33           /* size in bytes of DT_PREINIT_ARRAY */
./include/api/elf.h:#define DT_NUM          34              /* Number used */
./include/api/elf.h:#define DT_LOOS         0x6000000d      /* Start of OS-specific */
./include/api/elf.h:#define DT_HIOS         0x6ffff000      /* End of OS-specific */
./include/api/elf.h:#define DT_LOPROC       0x70000000      /* Start of processor-specific */
./include/api/elf.h:#define DT_HIPROC       0x7fffffff      /* End of processor-specific */
./include/api/elf.h:#define DT_PROCNUM      DT_MIPS_NUM     /* Most used by any processor */
./include/api/elf.h:/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
./include/api/elf.h:   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
./include/api/elf.h:#define DT_VALRNGLO     0x6ffffd00
./include/api/elf.h:#define DT_GNU_PRELINKED 0x6ffffdf5     /* Prelinking timestamp */
./include/api/elf.h:#define DT_GNU_CONFLICTSZ 0x6ffffdf6    /* Size of conflict section */
./include/api/elf.h:#define DT_GNU_LIBLISTSZ 0x6ffffdf7     /* Size of library list */
./include/api/elf.h:#define DT_CHECKSUM     0x6ffffdf8
./include/api/elf.h:#define DT_PLTPADSZ     0x6ffffdf9
./include/api/elf.h:#define DT_MOVEENT      0x6ffffdfa
./include/api/elf.h:#define DT_MOVESZ       0x6ffffdfb
./include/api/elf.h:#define DT_FEATURE_1    0x6ffffdfc      /* Feature selection (DTF_*).  */
./include/api/elf.h:#define DT_POSFLAG_1    0x6ffffdfd      /* Flags for DT_* entries, effecting
./include/api/elf.h:the following DT_* entry.  */
./include/api/elf.h:#define DT_SYMINSZ      0x6ffffdfe      /* Size of syminfo table (in bytes) */
./include/api/elf.h:#define DT_SYMINENT     0x6ffffdff      /* Entry size of syminfo */
./include/api/elf.h:#define DT_VALRNGHI     0x6ffffdff
./include/api/elf.h:#define DT_VALTAGIDX(tag)       (DT_VALRNGHI - (tag))   /* Reverse order! */
./include/api/elf.h:#define DT_VALNUM 12
./include/api/elf.h:/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
./include/api/elf.h:   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
./include/api/elf.h:   If any adjustment is made to the ELF object after it has been
./include/api/elf.h:#define DT_ADDRRNGLO    0x6ffffe00
./include/api/elf.h:#define DT_GNU_CONFLICT 0x6ffffef8      /* Start of conflict section */
./include/api/elf.h:#define DT_GNU_LIBLIST  0x6ffffef9      /* Library list */
./include/api/elf.h:#define DT_CONFIG       0x6ffffefa      /* Configuration information.  */
./include/api/elf.h:#define DT_DEPAUDIT     0x6ffffefb      /* Dependency auditing.  */
./include/api/elf.h:#define DT_AUDIT        0x6ffffefc      /* Object auditing.  */
./include/api/elf.h:#define DT_PLTPAD       0x6ffffefd      /* PLT padding.  */
./include/api/elf.h:#define DT_MOVETAB      0x6ffffefe      /* Move table.  */
./include/api/elf.h:#define DT_SYMINFO      0x6ffffeff      /* Syminfo table.  */
./include/api/elf.h:#define DT_ADDRRNGHI    0x6ffffeff
./include/api/elf.h:#define DT_ADDRTAGIDX(tag)      (DT_ADDRRNGHI - (tag))  /* Reverse order! */
./include/api/elf.h:#define DT_ADDRNUM 10
./include/api/elf.h:/* The versioning entry types.  The next are defined as part of the
./include/api/elf.h:#define DT_VERSYM       0x6ffffff0
./include/api/elf.h:#define DT_RELACOUNT    0x6ffffff9
./include/api/elf.h:#define DT_RELCOUNT     0x6ffffffa
./include/api/elf.h:#define DT_FLAGS_1      0x6ffffffb      /* State flags, see DF_1_* below.  */
./include/api/elf.h:#define DT_VERDEF       0x6ffffffc      /* Address of version definition
./include/api/elf.h:#define DT_VERDEFNUM    0x6ffffffd      /* Number of version definitions */
./include/api/elf.h:#define DT_VERNEED      0x6ffffffe      /* Address of table with needed
./include/api/elf.h:#define DT_VERNEEDNUM   0x6fffffff      /* Number of needed versions */
./include/api/elf.h:#define DT_VERSIONTAGIDX(tag)   (DT_VERNEEDNUM - (tag)) /* Reverse order! */
./include/api/elf.h:#define DT_VERSIONTAGNUM 16
./include/api/elf.h:/* Sun added these machine-independent extensions in the "processor-specific"
./include/api/elf.h:#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
./include/api/elf.h:#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
./include/api/elf.h:#define DT_EXTRATAGIDX(tag)     ((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
./include/api/elf.h:#define DT_EXTRANUM     3
./include/api/elf.h:/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
./include/api/elf.h:#define DF_ORIGIN       0x00000001      /* Object may use DF_ORIGIN */
./include/api/elf.h:#define DF_SYMBOLIC     0x00000002      /* Symbol resolutions starts here */
./include/api/elf.h:#define DF_TEXTREL      0x00000004      /* Object contains text relocations */
./include/api/elf.h:#define DF_BIND_NOW     0x00000008      /* No lazy binding for this object */
./include/api/elf.h:#define DF_STATIC_TLS   0x00000010      /* Module uses the static TLS model */
./include/api/elf.h:/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
./include/api/elf.h:#define DF_1_NOW        0x00000001      /* Set RTLD_NOW for this object.  */
./include/api/elf.h:#define DF_1_GLOBAL     0x00000002      /* Set RTLD_GLOBAL for this object.  */
./include/api/elf.h:#define DF_1_GROUP      0x00000004      /* Set RTLD_GROUP for this object.  */
./include/api/elf.h:#define DF_1_NODELETE   0x00000008      /* Set RTLD_NODELETE for this object.*/
./include/api/elf.h:#define DF_1_LOADFLTR   0x00000010      /* Trigger filtee loading at runtime.*/
./include/api/elf.h:#define DF_1_INITFIRST  0x00000020      /* Set RTLD_INITFIRST for this object*/
./include/api/elf.h:#define DF_1_NOOPEN     0x00000040      /* Set RTLD_NOOPEN for this object.  */
./include/api/elf.h:#define DF_1_ORIGIN     0x00000080      /* $ORIGIN must be handled.  */
./include/api/elf.h:#define DF_1_DIRECT     0x00000100      /* Direct binding enabled.  */
./include/api/elf.h:#define DF_1_TRANS      0x00000200
./include/api/elf.h:#define DF_1_INTERPOSE  0x00000400      /* Object is used to interpose.  */
./include/api/elf.h:#define DF_1_NODEFLIB   0x00000800      /* Ignore default lib search path.  */
./include/api/elf.h:#define DF_1_NODUMP     0x00001000      /* Object can't be dldump'ed.  */
./include/api/elf.h:#define DF_1_CONFALT    0x00002000      /* Configuration alternative created.*/
./include/api/elf.h:#define DF_1_ENDFILTEE  0x00004000      /* Filtee terminates filters search. */
./include/api/elf.h:#define DF_1_DISPRELDNE 0x00008000      /* Disp reloc applied at build time. */
./include/api/elf.h:#define DF_1_DISPRELPND 0x00010000      /* Disp reloc applied at run-time.  */
./include/api/elf.h:/* Flags for the feature selection in DT_FEATURE_1.  */
./include/api/elf.h:#define DTF_1_PARINIT   0x00000001
./include/api/elf.h:#define DTF_1_CONFEXP   0x00000002
./include/api/elf.h:/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
./include/api/elf.h:#define DF_P1_LAZYLOAD  0x00000001      /* Lazyload following object.  */
./include/api/elf.h:#define DF_P1_GROUPPERM 0x00000002      /* Symbols from next object are not
./include/api/elf.h:/* Version definition sections.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Half    vd_version;             /* Version revision */
./include/api/elf.h:        Elf32_Half    vd_flags;               /* Version information */
./include/api/elf.h:        Elf32_Half    vd_ndx;                 /* Version Index */
./include/api/elf.h:        Elf32_Half    vd_cnt;                 /* Number of associated aux entries */
./include/api/elf.h:        Elf32_Word    vd_hash;                /* Version name hash value */
./include/api/elf.h:        Elf32_Word    vd_aux;                 /* Offset in bytes to verdaux array */
./include/api/elf.h:        Elf32_Word    vd_next;                /* Offset in bytes to next verdef
./include/api/elf.h:} Elf32_Verdef;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Half    vd_version;             /* Version revision */
./include/api/elf.h:        Elf64_Half    vd_flags;               /* Version information */
./include/api/elf.h:        Elf64_Half    vd_ndx;                 /* Version Index */
./include/api/elf.h:        Elf64_Half    vd_cnt;                 /* Number of associated aux entries */
./include/api/elf.h:        Elf64_Word    vd_hash;                /* Version name hash value */
./include/api/elf.h:        Elf64_Word    vd_aux;                 /* Offset in bytes to verdaux array */
./include/api/elf.h:        Elf64_Word    vd_next;                /* Offset in bytes to next verdef
./include/api/elf.h:} Elf64_Verdef;
./include/api/elf.h:/* Legal values for vd_version (version revision).  */
./include/api/elf.h:#define VER_DEF_NONE    0               /* No version */
./include/api/elf.h:#define VER_DEF_CURRENT 1               /* Current version */
./include/api/elf.h:#define VER_DEF_NUM     2               /* Given version number */
./include/api/elf.h:/* Legal values for vd_flags (version information flags).  */
./include/api/elf.h:#define VER_FLG_BASE    0x1             /* Version definition of file itself */
./include/api/elf.h:#define VER_FLG_WEAK    0x2             /* Weak version identifier */
./include/api/elf.h:#define VER_NDX_LOCAL           0       /* Symbol is local.  */
./include/api/elf.h:#define VER_NDX_GLOBAL          1       /* Symbol is global.  */
./include/api/elf.h:#define VER_NDX_LORESERVE       0xff00  /* Beginning of reserved entries.  */
./include/api/elf.h:#define VER_NDX_ELIMINATE       0xff01  /* Symbol is to be eliminated.  */
./include/api/elf.h:/* Auxialiary version information.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    vda_name;               /* Version or dependency names */
./include/api/elf.h:        Elf32_Word    vda_next;               /* Offset in bytes to next verdaux
./include/api/elf.h:} Elf32_Verdaux;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word    vda_name;               /* Version or dependency names */
./include/api/elf.h:        Elf64_Word    vda_next;               /* Offset in bytes to next verdaux
./include/api/elf.h:} Elf64_Verdaux;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Half    vn_version;             /* Version of structure */
./include/api/elf.h:        Elf32_Half    vn_cnt;                 /* Number of associated aux entries */
./include/api/elf.h:        Elf32_Word    vn_file;                /* Offset of filename for this
./include/api/elf.h:        Elf32_Word    vn_aux;                 /* Offset in bytes to vernaux array */
./include/api/elf.h:        Elf32_Word    vn_next;                /* Offset in bytes to next verneed
./include/api/elf.h:} Elf32_Verneed;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Half    vn_version;             /* Version of structure */
./include/api/elf.h:        Elf64_Half    vn_cnt;                 /* Number of associated aux entries */
./include/api/elf.h:        Elf64_Word    vn_file;                /* Offset of filename for this
./include/api/elf.h:        Elf64_Word    vn_aux;                 /* Offset in bytes to vernaux array */
./include/api/elf.h:        Elf64_Word    vn_next;                /* Offset in bytes to next verneed
./include/api/elf.h:} Elf64_Verneed;
./include/api/elf.h:/* Legal values for vn_version (version revision).  */
./include/api/elf.h:#define VER_NEED_NONE    0              /* No version */
./include/api/elf.h:#define VER_NEED_CURRENT 1              /* Current version */
./include/api/elf.h:#define VER_NEED_NUM     2              /* Given version number */
./include/api/elf.h:/* Auxiliary needed version information.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    vna_hash;               /* Hash value of dependency name */
./include/api/elf.h:        Elf32_Half    vna_flags;              /* Dependency specific information */
./include/api/elf.h:        Elf32_Half    vna_other;              /* Unused */
./include/api/elf.h:        Elf32_Word    vna_name;               /* Dependency name string offset */
./include/api/elf.h:        Elf32_Word    vna_next;               /* Offset in bytes to next vernaux
./include/api/elf.h:} Elf32_Vernaux;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word    vna_hash;               /* Hash value of dependency name */
./include/api/elf.h:        Elf64_Half    vna_flags;              /* Dependency specific information */
./include/api/elf.h:        Elf64_Half    vna_other;              /* Unused */
./include/api/elf.h:        Elf64_Word    vna_name;               /* Dependency name string offset */
./include/api/elf.h:        Elf64_Word    vna_next;               /* Offset in bytes to next vernaux
./include/api/elf.h:} Elf64_Vernaux;
./include/api/elf.h:/* Legal values for vna_flags.  */
./include/api/elf.h:#define VER_FLG_WEAK    0x2             /* Weak version identifier */
./include/api/elf.h:   usual definition in an ABI supplement uses the name auxv_t.  The
./include/api/elf.h:   vector is not usually defined in a standard <elf.h> file, but it
./include/api/elf.h:   can't hurt.  We rename it to avoid conflicts.  The sizes of these
./include/api/elf.h:   interpreter, so we don't fully specify them here.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:                void (*a_fcn)(void);      /* Function pointer value */
./include/api/elf.h:} Elf32_auxv_t;
./include/api/elf.h:typedef struct {
./include/api/elf.h:                void (*a_fcn)(void);      /* Function pointer value */
./include/api/elf.h:} Elf64_auxv_t;
./include/api/elf.h:/* Legal values for a_type (entry type).  */
./include/api/elf.h:#define AT_NULL         0               /* End of vector */
./include/api/elf.h:#define AT_IGNORE       1               /* Entry should be ignored */
./include/api/elf.h:#define AT_EXECFD       2               /* File descriptor of program */
./include/api/elf.h:#define AT_PHDR         3               /* Program headers for program */
./include/api/elf.h:#define AT_PHENT        4               /* Size of program header entry */
./include/api/elf.h:#define AT_PHNUM        5               /* Number of program headers */
./include/api/elf.h:#define AT_PAGESZ       6               /* System page size */
./include/api/elf.h:#define AT_BASE         7               /* Base address of interpreter */
./include/api/elf.h:#define AT_FLAGS        8               /* Flags */
./include/api/elf.h:#define AT_ENTRY        9               /* Entry point of program */
./include/api/elf.h:#define AT_NOTELF       10              /* Program is not ELF */
./include/api/elf.h:#define AT_UID          11              /* Real uid */
./include/api/elf.h:#define AT_EUID         12              /* Effective uid */
./include/api/elf.h:#define AT_GID          13              /* Real gid */
./include/api/elf.h:#define AT_EGID         14              /* Effective gid */
./include/api/elf.h:#define AT_CLKTCK       17              /* Frequency of times() */
./include/api/elf.h:#define AT_PLATFORM     15              /* String identifying platform.  */
./include/api/elf.h:#define AT_HWCAP        16              /* Machine dependent hints about
./include/api/elf.h:/* This entry gives some information about the FPU initialization
./include/api/elf.h:   performed by the kernel.  */
./include/api/elf.h:#define AT_FPUCW        18              /* Used FPU control word.  */
./include/api/elf.h:#define AT_DCACHEBSIZE  19              /* Data cache block size.  */
./include/api/elf.h:#define AT_ICACHEBSIZE  20              /* Instruction cache block size.  */
./include/api/elf.h:#define AT_UCACHEBSIZE  21              /* Unified cache block size.  */
./include/api/elf.h:/* A special ignored value for PPC, used by the kernel to control the
./include/api/elf.h:   interpretation of the AUXV. Must be > 16.  */
./include/api/elf.h:#define AT_IGNOREPPC    22              /* Entry should be ignored.  */
./include/api/elf.h:#define AT_SECURE       23              /* Boolean, was exec setuid-like?  */
./include/api/elf.h:/* Pointer to the global system page used for system calls and other
./include/api/elf.h:#define AT_SYSINFO      32
./include/api/elf.h:#define AT_SYSINFO_EHDR 33
./include/api/elf.h:/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
./include/api/elf.h:   log2 of line size; mask those to get cache size.  */
./include/api/elf.h:#define AT_L1I_CACHESHAPE       34
./include/api/elf.h:#define AT_L1D_CACHESHAPE       35
./include/api/elf.h:#define AT_L2_CACHESHAPE        36
./include/api/elf.h:#define AT_L3_CACHESHAPE        37
./include/api/elf.h:   a header of a fixed form.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word n_namesz;                  /* Length of the note's name.  */
./include/api/elf.h:        Elf32_Word n_descsz;                  /* Length of the note's descriptor.  */
./include/api/elf.h:        Elf32_Word n_type;                    /* Type of the note.  */
./include/api/elf.h:} Elf32_Nhdr;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word n_namesz;                  /* Length of the note's name.  */
./include/api/elf.h:        Elf64_Word n_descsz;                  /* Length of the note's descriptor.  */
./include/api/elf.h:        Elf64_Word n_type;                    /* Type of the note.  */
./include/api/elf.h:} Elf64_Nhdr;
./include/api/elf.h:/* Known names of notes.  */
./include/api/elf.h:#define ELF_NOTE_SOLARIS        "SUNW Solaris"
./include/api/elf.h:/* Note entries for GNU systems have this name.  */
./include/api/elf.h:#define ELF_NOTE_GNU            "GNU"
./include/api/elf.h:/* Defined types of notes for Solaris.  */
./include/api/elf.h:/* Value of descriptor (one word) is desired pagesize for the binary.  */
./include/api/elf.h:#define ELF_NOTE_PAGESIZE_HINT  1
./include/api/elf.h:/* Defined note types for GNU systems.  */
./include/api/elf.h:/* ABI information.  The descriptor consists of words:
./include/api/elf.h:   word 1: major version of the ABI
./include/api/elf.h:   word 2: minor version of the ABI
./include/api/elf.h:   word 3: subminor version of the ABI
./include/api/elf.h:#define ELF_NOTE_ABI            1
./include/api/elf.h:/* Known OSes.  These value can appear in word 0 of an ELF_NOTE_ABI
./include/api/elf.h:#define ELF_NOTE_OS_LINUX       0
./include/api/elf.h:#define ELF_NOTE_OS_GNU         1
./include/api/elf.h:#define ELF_NOTE_OS_SOLARIS2    2
./include/api/elf.h:#define ELF_NOTE_OS_FREEBSD     3
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Xword m_value;          /* Symbol value.  */
./include/api/elf.h:        Elf32_Word m_info;            /* Size and index.  */
./include/api/elf.h:        Elf32_Word m_poffset;         /* Symbol offset.  */
./include/api/elf.h:        Elf32_Half m_repeat;          /* Repeat count.  */
./include/api/elf.h:        Elf32_Half m_stride;          /* Stride info.  */
./include/api/elf.h:} Elf32_Move;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Xword m_value;          /* Symbol value.  */
./include/api/elf.h:        Elf64_Xword m_info;           /* Size and index.  */
./include/api/elf.h:        Elf64_Xword m_poffset;        /* Symbol offset.  */
./include/api/elf.h:        Elf64_Half m_repeat;          /* Repeat count.  */
./include/api/elf.h:        Elf64_Half m_stride;          /* Stride info.  */
./include/api/elf.h:} Elf64_Move;
./include/api/elf.h:#define ELF32_M_SYM(info)       ((info) >> 8)
./include/api/elf.h:#define ELF32_M_SIZE(info)      ((unsigned char) (info))
./include/api/elf.h:#define ELF32_M_INFO(sym, size) (((sym) << 8) + (unsigned char) (size))
./include/api/elf.h:#define ELF64_M_SYM(info)       ELF32_M_SYM (info)
./include/api/elf.h:#define ELF64_M_SIZE(info)      ELF32_M_SIZE (info)
./include/api/elf.h:#define ELF64_M_INFO(sym, size) ELF32_M_INFO (sym, size)
./include/api/elf.h:/* Motorola 68k specific definitions.  */
./include/api/elf.h:/* Values for Elf32_Ehdr.e_flags.  */
./include/api/elf.h:#define EF_CPU32        0x00810000
./include/api/elf.h:#define R_68K_NONE      0               /* No reloc */
./include/api/elf.h:#define R_68K_32        1               /* Direct 32 bit  */
./include/api/elf.h:#define R_68K_16        2               /* Direct 16 bit  */
./include/api/elf.h:#define R_68K_8         3               /* Direct 8 bit  */
./include/api/elf.h:#define R_68K_PC32      4               /* PC relative 32 bit */
./include/api/elf.h:#define R_68K_PC16      5               /* PC relative 16 bit */
./include/api/elf.h:#define R_68K_PC8       6               /* PC relative 8 bit */
./include/api/elf.h:#define R_68K_GOT32     7               /* 32 bit PC relative GOT entry */
./include/api/elf.h:#define R_68K_GOT16     8               /* 16 bit PC relative GOT entry */
./include/api/elf.h:#define R_68K_GOT8      9               /* 8 bit PC relative GOT entry */
./include/api/elf.h:#define R_68K_GOT32O    10              /* 32 bit GOT offset */
./include/api/elf.h:#define R_68K_GOT16O    11              /* 16 bit GOT offset */
./include/api/elf.h:#define R_68K_GOT8O     12              /* 8 bit GOT offset */
./include/api/elf.h:#define R_68K_PLT32     13              /* 32 bit PC relative PLT address */
./include/api/elf.h:#define R_68K_PLT16     14              /* 16 bit PC relative PLT address */
./include/api/elf.h:#define R_68K_PLT8      15              /* 8 bit PC relative PLT address */
./include/api/elf.h:#define R_68K_PLT32O    16              /* 32 bit PLT offset */
./include/api/elf.h:#define R_68K_PLT16O    17              /* 16 bit PLT offset */
./include/api/elf.h:#define R_68K_PLT8O     18              /* 8 bit PLT offset */
./include/api/elf.h:#define R_68K_COPY      19              /* Copy symbol at runtime */
./include/api/elf.h:#define R_68K_GLOB_DAT  20              /* Create GOT entry */
./include/api/elf.h:#define R_68K_JMP_SLOT  21              /* Create PLT entry */
./include/api/elf.h:#define R_68K_RELATIVE  22              /* Adjust by program base */
./include/api/elf.h:#define R_68K_NUM       23
./include/api/elf.h:/* Intel 80386 specific definitions.  */
./include/api/elf.h:#define R_386_NONE         0            /* No reloc */
./include/api/elf.h:#define R_386_32           1            /* Direct 32 bit  */
./include/api/elf.h:#define R_386_PC32         2            /* PC relative 32 bit */
./include/api/elf.h:#define R_386_GOT32        3            /* 32 bit GOT entry */
./include/api/elf.h:#define R_386_PLT32        4            /* 32 bit PLT address */
./include/api/elf.h:#define R_386_COPY         5            /* Copy symbol at runtime */
./include/api/elf.h:#define R_386_GLOB_DAT     6            /* Create GOT entry */
./include/api/elf.h:#define R_386_JMP_SLOT     7            /* Create PLT entry */
./include/api/elf.h:#define R_386_RELATIVE     8            /* Adjust by program base */
./include/api/elf.h:#define R_386_GOTOFF       9            /* 32 bit offset to GOT */
./include/api/elf.h:#define R_386_GOTPC        10           /* 32 bit PC relative offset to GOT */
./include/api/elf.h:#define R_386_32PLT        11
./include/api/elf.h:#define R_386_TLS_TPOFF    14           /* Offset in static TLS block */
./include/api/elf.h:#define R_386_TLS_IE       15           /* Address of GOT entry for static TLS
./include/api/elf.h:block offset */
./include/api/elf.h:#define R_386_TLS_GOTIE    16           /* GOT entry for static TLS block
./include/api/elf.h:offset */
./include/api/elf.h:#define R_386_TLS_LE       17           /* Offset relative to static TLS
./include/api/elf.h:#define R_386_TLS_GD       18           /* Direct 32 bit for GNU version of
./include/api/elf.h:#define R_386_TLS_LDM      19           /* Direct 32 bit for GNU version of
./include/api/elf.h:#define R_386_16           20
./include/api/elf.h:#define R_386_PC16         21
./include/api/elf.h:#define R_386_8            22
./include/api/elf.h:#define R_386_PC8          23
./include/api/elf.h:#define R_386_TLS_GD_32    24           /* Direct 32 bit for general dynamic
./include/api/elf.h:#define R_386_TLS_GD_PUSH  25           /* Tag for pushl in GD TLS code */
./include/api/elf.h:#define R_386_TLS_GD_CALL  26           /* Relocation for call to
./include/api/elf.h:#define R_386_TLS_GD_POP   27           /* Tag for popl in GD TLS code */
./include/api/elf.h:#define R_386_TLS_LDM_32   28           /* Direct 32 bit for local dynamic
./include/api/elf.h:#define R_386_TLS_LDM_PUSH 29           /* Tag for pushl in LDM TLS code */
./include/api/elf.h:#define R_386_TLS_LDM_CALL 30           /* Relocation for call to
./include/api/elf.h:#define R_386_TLS_LDM_POP  31           /* Tag for popl in LDM TLS code */
./include/api/elf.h:#define R_386_TLS_LDO_32   32           /* Offset relative to TLS block */
./include/api/elf.h:#define R_386_TLS_IE_32    33           /* GOT entry for negated static TLS
./include/api/elf.h:block offset */
./include/api/elf.h:#define R_386_TLS_LE_32    34           /* Negated offset relative to static
./include/api/elf.h:#define R_386_TLS_DTPMOD32 35           /* ID of module containing symbol */
./include/api/elf.h:#define R_386_TLS_DTPOFF32 36           /* Offset in TLS block */
./include/api/elf.h:#define R_386_TLS_TPOFF32  37           /* Negated offset in static TLS block */
./include/api/elf.h:#define R_386_NUM          38
./include/api/elf.h:/* SUN SPARC specific definitions.  */
./include/api/elf.h:/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
./include/api/elf.h:#define STT_SPARC_REGISTER      13      /* Global register reserved to app. */
./include/api/elf.h:/* Values for Elf64_Ehdr.e_flags.  */
./include/api/elf.h:#define EF_SPARCV9_MM           3
./include/api/elf.h:#define EF_SPARCV9_TSO          0
./include/api/elf.h:#define EF_SPARCV9_PSO          1
./include/api/elf.h:#define EF_SPARCV9_RMO          2
./include/api/elf.h:#define EF_SPARC_LEDATA         0x800000 /* little endian data */
./include/api/elf.h:#define EF_SPARC_EXT_MASK       0xFFFF00
./include/api/elf.h:#define EF_SPARC_32PLUS         0x000100 /* generic V8+ features */
./include/api/elf.h:#define EF_SPARC_SUN_US1        0x000200 /* Sun UltraSPARC1 extensions */
./include/api/elf.h:#define EF_SPARC_HAL_R1         0x000400 /* HAL R1 extensions */
./include/api/elf.h:#define EF_SPARC_SUN_US3        0x000800 /* Sun UltraSPARCIII extensions */
./include/api/elf.h:#define R_SPARC_NONE            0       /* No reloc */
./include/api/elf.h:#define R_SPARC_8               1       /* Direct 8 bit */
./include/api/elf.h:#define R_SPARC_16              2       /* Direct 16 bit */
./include/api/elf.h:#define R_SPARC_32              3       /* Direct 32 bit */
./include/api/elf.h:#define R_SPARC_DISP8           4       /* PC relative 8 bit */
./include/api/elf.h:#define R_SPARC_DISP16          5       /* PC relative 16 bit */
./include/api/elf.h:#define R_SPARC_DISP32          6       /* PC relative 32 bit */
./include/api/elf.h:#define R_SPARC_WDISP30         7       /* PC relative 30 bit shifted */
./include/api/elf.h:#define R_SPARC_WDISP22         8       /* PC relative 22 bit shifted */
./include/api/elf.h:#define R_SPARC_HI22            9       /* High 22 bit */
./include/api/elf.h:#define R_SPARC_22              10      /* Direct 22 bit */
./include/api/elf.h:#define R_SPARC_13              11      /* Direct 13 bit */
./include/api/elf.h:#define R_SPARC_LO10            12      /* Truncated 10 bit */
./include/api/elf.h:#define R_SPARC_GOT10           13      /* Truncated 10 bit GOT entry */
./include/api/elf.h:#define R_SPARC_GOT13           14      /* 13 bit GOT entry */
./include/api/elf.h:#define R_SPARC_GOT22           15      /* 22 bit GOT entry shifted */
./include/api/elf.h:#define R_SPARC_PC10            16      /* PC relative 10 bit truncated */
./include/api/elf.h:#define R_SPARC_PC22            17      /* PC relative 22 bit shifted */
./include/api/elf.h:#define R_SPARC_WPLT30          18      /* 30 bit PC relative PLT address */
./include/api/elf.h:#define R_SPARC_COPY            19      /* Copy symbol at runtime */
./include/api/elf.h:#define R_SPARC_GLOB_DAT        20      /* Create GOT entry */
./include/api/elf.h:#define R_SPARC_JMP_SLOT        21      /* Create PLT entry */
./include/api/elf.h:#define R_SPARC_RELATIVE        22      /* Adjust by program base */
./include/api/elf.h:#define R_SPARC_UA32            23      /* Direct 32 bit unaligned */
./include/api/elf.h:#define R_SPARC_PLT32           24      /* Direct 32 bit ref to PLT entry */
./include/api/elf.h:#define R_SPARC_HIPLT22         25      /* High 22 bit PLT entry */
./include/api/elf.h:#define R_SPARC_LOPLT10         26      /* Truncated 10 bit PLT entry */
./include/api/elf.h:#define R_SPARC_PCPLT32         27      /* PC rel 32 bit ref to PLT entry */
./include/api/elf.h:#define R_SPARC_PCPLT22         28      /* PC rel high 22 bit PLT entry */
./include/api/elf.h:#define R_SPARC_PCPLT10         29      /* PC rel trunc 10 bit PLT entry */
./include/api/elf.h:#define R_SPARC_10              30      /* Direct 10 bit */
./include/api/elf.h:#define R_SPARC_11              31      /* Direct 11 bit */
./include/api/elf.h:#define R_SPARC_64              32      /* Direct 64 bit */
./include/api/elf.h:#define R_SPARC_OLO10           33      /* 10bit with secondary 13bit addend */
./include/api/elf.h:#define R_SPARC_HH22            34      /* Top 22 bits of direct 64 bit */
./include/api/elf.h:#define R_SPARC_HM10            35      /* High middle 10 bits of ... */
./include/api/elf.h:#define R_SPARC_LM22            36      /* Low middle 22 bits of ... */
./include/api/elf.h:#define R_SPARC_PC_HH22         37      /* Top 22 bits of pc rel 64 bit */
./include/api/elf.h:#define R_SPARC_PC_HM10         38      /* High middle 10 bit of ... */
./include/api/elf.h:#define R_SPARC_PC_LM22         39      /* Low miggle 22 bits of ... */
./include/api/elf.h:#define R_SPARC_WDISP16         40      /* PC relative 16 bit shifted */
./include/api/elf.h:#define R_SPARC_WDISP19         41      /* PC relative 19 bit shifted */
./include/api/elf.h:#define R_SPARC_7               43      /* Direct 7 bit */
./include/api/elf.h:#define R_SPARC_5               44      /* Direct 5 bit */
./include/api/elf.h:#define R_SPARC_6               45      /* Direct 6 bit */
./include/api/elf.h:#define R_SPARC_DISP64          46      /* PC relative 64 bit */
./include/api/elf.h:#define R_SPARC_PLT64           47      /* Direct 64 bit ref to PLT entry */
./include/api/elf.h:#define R_SPARC_HIX22           48      /* High 22 bit complemented */
./include/api/elf.h:#define R_SPARC_LOX10           49      /* Truncated 11 bit complemented */
./include/api/elf.h:#define R_SPARC_H44             50      /* Direct high 12 of 44 bit */
./include/api/elf.h:#define R_SPARC_M44             51      /* Direct mid 22 of 44 bit */
./include/api/elf.h:#define R_SPARC_L44             52      /* Direct low 10 of 44 bit */
./include/api/elf.h:#define R_SPARC_REGISTER        53      /* Global register usage */
./include/api/elf.h:#define R_SPARC_UA64            54      /* Direct 64 bit unaligned */
./include/api/elf.h:#define R_SPARC_UA16            55      /* Direct 16 bit unaligned */
./include/api/elf.h:#define R_SPARC_TLS_GD_HI22     56
./include/api/elf.h:#define R_SPARC_TLS_GD_LO10     57
./include/api/elf.h:#define R_SPARC_TLS_GD_ADD      58
./include/api/elf.h:#define R_SPARC_TLS_GD_CALL     59
./include/api/elf.h:#define R_SPARC_TLS_LDM_HI22    60
./include/api/elf.h:#define R_SPARC_TLS_LDM_LO10    61
./include/api/elf.h:#define R_SPARC_TLS_LDM_ADD     62
./include/api/elf.h:#define R_SPARC_TLS_LDM_CALL    63
./include/api/elf.h:#define R_SPARC_TLS_LDO_HIX22   64
./include/api/elf.h:#define R_SPARC_TLS_LDO_LOX10   65
./include/api/elf.h:#define R_SPARC_TLS_LDO_ADD     66
./include/api/elf.h:#define R_SPARC_TLS_IE_HI22     67
./include/api/elf.h:#define R_SPARC_TLS_IE_LO10     68
./include/api/elf.h:#define R_SPARC_TLS_IE_LD       69
./include/api/elf.h:#define R_SPARC_TLS_IE_LDX      70
./include/api/elf.h:#define R_SPARC_TLS_IE_ADD      71
./include/api/elf.h:#define R_SPARC_TLS_LE_HIX22    72
./include/api/elf.h:#define R_SPARC_TLS_LE_LOX10    73
./include/api/elf.h:#define R_SPARC_TLS_DTPMOD32    74
./include/api/elf.h:#define R_SPARC_TLS_DTPMOD64    75
./include/api/elf.h:#define R_SPARC_TLS_DTPOFF32    76
./include/api/elf.h:#define R_SPARC_TLS_DTPOFF64    77
./include/api/elf.h:#define R_SPARC_TLS_TPOFF32     78
./include/api/elf.h:#define R_SPARC_TLS_TPOFF64     79
./include/api/elf.h:#define R_SPARC_NUM             80
./include/api/elf.h:/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
./include/api/elf.h:#define DT_SPARC_REGISTER 0x70000001
./include/api/elf.h:#define DT_SPARC_NUM    2
./include/api/elf.h:/* Bits present in AT_HWCAP, primarily for Sparc32.  */
./include/api/elf.h:#define HWCAP_SPARC_FLUSH       1       /* The cpu supports flush insn.  */
./include/api/elf.h:#define HWCAP_SPARC_STBAR       2
./include/api/elf.h:#define HWCAP_SPARC_SWAP        4
./include/api/elf.h:#define HWCAP_SPARC_MULDIV      8
./include/api/elf.h:#define HWCAP_SPARC_V9          16      /* The cpu is v9, so v8plus is ok.  */
./include/api/elf.h:#define HWCAP_SPARC_ULTRA3      32
./include/api/elf.h:/* MIPS R3000 specific definitions.  */
./include/api/elf.h:/* Legal values for e_flags field of Elf32_Ehdr.  */
./include/api/elf.h:#define EF_MIPS_NOREORDER   1           /* A .noreorder directive was used */
./include/api/elf.h:#define EF_MIPS_PIC         2           /* Contains PIC code */
./include/api/elf.h:#define EF_MIPS_CPIC        4           /* Uses PIC calling sequence */
./include/api/elf.h:#define EF_MIPS_XGOT        8
./include/api/elf.h:#define EF_MIPS_64BIT_WHIRL 16
./include/api/elf.h:#define EF_MIPS_ABI2        32
./include/api/elf.h:#define EF_MIPS_ABI_ON32    64
./include/api/elf.h:#define EF_MIPS_ARCH        0xf0000000  /* MIPS architecture level */
./include/api/elf.h:/* Legal values for MIPS architecture level.  */
./include/api/elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_32     0x60000000  /* MIPS32 code.  */
./include/api/elf.h:#define EF_MIPS_ARCH_64     0x70000000  /* MIPS64 code.  */
./include/api/elf.h:/* The following are non-official names and should not be used.  */
./include/api/elf.h:#define E_MIPS_ARCH_1     0x00000000    /* -mips1 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_2     0x10000000    /* -mips2 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_3     0x20000000    /* -mips3 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_4     0x30000000    /* -mips4 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_5     0x40000000    /* -mips5 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_32    0x60000000    /* MIPS32 code.  */
./include/api/elf.h:#define E_MIPS_ARCH_64    0x70000000    /* MIPS64 code.  */
./include/api/elf.h:#define SHN_MIPS_ACOMMON    0xff00      /* Allocated common symbols */
./include/api/elf.h:#define SHN_MIPS_TEXT       0xff01      /* Allocated test symbols.  */
./include/api/elf.h:#define SHN_MIPS_DATA       0xff02      /* Allocated data symbols.  */
./include/api/elf.h:#define SHN_MIPS_SCOMMON    0xff03      /* Small common symbols */
./include/api/elf.h:#define SHN_MIPS_SUNDEFINED 0xff04      /* Small undefined symbols */
./include/api/elf.h:/* Legal values for sh_type field of Elf32_Shdr.  */
./include/api/elf.h:#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
./include/api/elf.h:#define SHT_MIPS_MSYM          0x70000001
./include/api/elf.h:#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
./include/api/elf.h:#define SHT_MIPS_GPTAB         0x70000003 /* Global data area sizes */
./include/api/elf.h:#define SHT_MIPS_UCODE         0x70000004 /* Reserved for SGI/MIPS compilers */
./include/api/elf.h:#define SHT_MIPS_DEBUG         0x70000005 /* MIPS ECOFF debugging information*/
./include/api/elf.h:#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
./include/api/elf.h:#define SHT_MIPS_PACKAGE       0x70000007
./include/api/elf.h:#define SHT_MIPS_PACKSYM       0x70000008
./include/api/elf.h:#define SHT_MIPS_RELD          0x70000009
./include/api/elf.h:#define SHT_MIPS_IFACE         0x7000000b
./include/api/elf.h:#define SHT_MIPS_CONTENT       0x7000000c
./include/api/elf.h:#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
./include/api/elf.h:#define SHT_MIPS_SHDR          0x70000010
./include/api/elf.h:#define SHT_MIPS_FDESC         0x70000011
./include/api/elf.h:#define SHT_MIPS_EXTSYM        0x70000012
./include/api/elf.h:#define SHT_MIPS_DENSE         0x70000013
./include/api/elf.h:#define SHT_MIPS_PDESC         0x70000014
./include/api/elf.h:#define SHT_MIPS_LOCSYM        0x70000015
./include/api/elf.h:#define SHT_MIPS_AUXSYM        0x70000016
./include/api/elf.h:#define SHT_MIPS_OPTSYM        0x70000017
./include/api/elf.h:#define SHT_MIPS_LOCSTR        0x70000018
./include/api/elf.h:#define SHT_MIPS_LINE          0x70000019
./include/api/elf.h:#define SHT_MIPS_RFDESC        0x7000001a
./include/api/elf.h:#define SHT_MIPS_DELTASYM      0x7000001b
./include/api/elf.h:#define SHT_MIPS_DELTAINST     0x7000001c
./include/api/elf.h:#define SHT_MIPS_DELTACLASS    0x7000001d
./include/api/elf.h:#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
./include/api/elf.h:#define SHT_MIPS_DELTADECL     0x7000001f
./include/api/elf.h:#define SHT_MIPS_SYMBOL_LIB    0x70000020
./include/api/elf.h:#define SHT_MIPS_EVENTS        0x70000021 /* Event section.  */
./include/api/elf.h:#define SHT_MIPS_TRANSLATE     0x70000022
./include/api/elf.h:#define SHT_MIPS_PIXIE         0x70000023
./include/api/elf.h:#define SHT_MIPS_XLATE         0x70000024
./include/api/elf.h:#define SHT_MIPS_XLATE_DEBUG   0x70000025
./include/api/elf.h:#define SHT_MIPS_WHIRL         0x70000026
./include/api/elf.h:#define SHT_MIPS_EH_REGION     0x70000027
./include/api/elf.h:#define SHT_MIPS_XLATE_OLD     0x70000028
./include/api/elf.h:#define SHT_MIPS_PDR_EXCEPTION 0x70000029
./include/api/elf.h:/* Legal values for sh_flags field of Elf32_Shdr.  */
./include/api/elf.h:#define SHF_MIPS_GPREL   0x10000000     /* Must be part of global data area */
./include/api/elf.h:#define SHF_MIPS_MERGE   0x20000000
./include/api/elf.h:#define SHF_MIPS_ADDR    0x40000000
./include/api/elf.h:#define SHF_MIPS_STRINGS 0x80000000
./include/api/elf.h:#define SHF_MIPS_NOSTRIP 0x08000000
./include/api/elf.h:#define SHF_MIPS_LOCAL   0x04000000
./include/api/elf.h:#define SHF_MIPS_NAMES   0x02000000
./include/api/elf.h:#define SHF_MIPS_NODUPE  0x01000000
./include/api/elf.h:/* MIPS specific values for `st_other'.  */
./include/api/elf.h:#define STO_MIPS_DEFAULT                0x0
./include/api/elf.h:#define STO_MIPS_INTERNAL               0x1
./include/api/elf.h:#define STO_MIPS_HIDDEN                 0x2
./include/api/elf.h:#define STO_MIPS_PROTECTED              0x3
./include/api/elf.h:#define STO_MIPS_SC_ALIGN_UNUSED        0xff
./include/api/elf.h:/* MIPS specific values for `st_info'.  */
./include/api/elf.h:#define STB_MIPS_SPLIT_COMMON           13
./include/api/elf.h:/* Entries found in sections of type SHT_MIPS_GPTAB.  */
./include/api/elf.h:typedef union {
./include/api/elf.h:                Elf32_Word gt_current_g_value;    /* -G value used for compilation */
./include/api/elf.h:                Elf32_Word gt_unused;             /* Not used */
./include/api/elf.h:                Elf32_Word gt_g_value;            /* If this value were used for -G */
./include/api/elf.h:                Elf32_Word gt_bytes;              /* This many bytes would be used */
./include/api/elf.h:} Elf32_gptab;
./include/api/elf.h:/* Entry found in sections of type SHT_MIPS_REGINFO.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word    ri_gprmask;             /* General registers used */
./include/api/elf.h:        Elf32_Word    ri_cprmask[4];          /* Coprocessor registers used */
./include/api/elf.h:        Elf32_Sword   ri_gp_value;            /* $gp register value */
./include/api/elf.h:} Elf32_RegInfo;
./include/api/elf.h:/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        unsigned char kind;           /* Determines interpretation of the
./include/api/elf.h:                                   variable part of descriptor.  */
./include/api/elf.h:        unsigned char size;           /* Size of descriptor, including header.  */
./include/api/elf.h:        Elf32_Section section;        /* Section header index of section affected,
./include/api/elf.h:                                   0 for global options.  */
./include/api/elf.h:        Elf32_Word info;              /* Kind-specific information.  */
./include/api/elf.h:} Elf_Options;
./include/api/elf.h:/* Values for `kind' field in Elf_Options.  */
./include/api/elf.h:#define ODK_NULL        0       /* Undefined.  */
./include/api/elf.h:#define ODK_REGINFO     1       /* Register usage information.  */
./include/api/elf.h:#define ODK_EXCEPTIONS  2       /* Exception processing options.  */
./include/api/elf.h:#define ODK_PAD         3       /* Section padding options.  */
./include/api/elf.h:#define ODK_HWPATCH     4       /* Hardware workarounds performed */
./include/api/elf.h:#define ODK_FILL        5       /* record the fill value used by the linker. */
./include/api/elf.h:#define ODK_TAGS        6       /* reserve space for desktop tools to write. */
./include/api/elf.h:#define ODK_HWAND       7       /* HW workarounds.  'AND' bits when merging. */
./include/api/elf.h:#define ODK_HWOR        8       /* HW workarounds.  'OR' bits when merging.  */
./include/api/elf.h:/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
./include/api/elf.h:#define OEX_FPU_MIN     0x1f    /* FPE's which MUST be enabled.  */
./include/api/elf.h:#define OEX_FPU_MAX     0x1f00  /* FPE's which MAY be enabled.  */
./include/api/elf.h:#define OEX_PAGE0       0x10000 /* page zero must be mapped.  */
./include/api/elf.h:#define OEX_SMM         0x20000 /* Force sequential memory mode?  */
./include/api/elf.h:#define OEX_FPDBUG      0x40000 /* Force floating point debug mode?  */
./include/api/elf.h:#define OEX_PRECISEFP   OEX_FPDBUG
./include/api/elf.h:#define OEX_DISMISS     0x80000 /* Dismiss invalid address faults?  */
./include/api/elf.h:#define OEX_FPU_INVAL   0x10
./include/api/elf.h:#define OEX_FPU_DIV0    0x08
./include/api/elf.h:#define OEX_FPU_OFLO    0x04
./include/api/elf.h:#define OEX_FPU_UFLO    0x02
./include/api/elf.h:#define OEX_FPU_INEX    0x01
./include/api/elf.h:/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
./include/api/elf.h:#define OHW_R4KEOP      0x1     /* R4000 end-of-page patch.  */
./include/api/elf.h:#define OHW_R8KPFETCH   0x2     /* may need R8000 prefetch patch.  */
./include/api/elf.h:#define OHW_R5KEOP      0x4     /* R5000 end-of-page patch.  */
./include/api/elf.h:#define OHW_R5KCVTL     0x8     /* R5000 cvt.[ds].l bug.  clean=1.  */
./include/api/elf.h:#define OPAD_PREFIX     0x1
./include/api/elf.h:#define OPAD_POSTFIX    0x2
./include/api/elf.h:#define OPAD_SYMBOL     0x4
./include/api/elf.h:/* Entry found in `.options' section.  */
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf32_Word hwp_flags1;        /* Extra flags.  */
./include/api/elf.h:        Elf32_Word hwp_flags2;        /* Extra flags.  */
./include/api/elf.h:} Elf_Options_Hw;
./include/api/elf.h:/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
./include/api/elf.h:#define OHWA0_R4KEOP_CHECKED    0x00000001
./include/api/elf.h:#define OHWA1_R4KEOP_CLEAN      0x00000002
./include/api/elf.h:#define R_MIPS_NONE             0       /* No reloc */
./include/api/elf.h:#define R_MIPS_16               1       /* Direct 16 bit */
./include/api/elf.h:#define R_MIPS_32               2       /* Direct 32 bit */
./include/api/elf.h:#define R_MIPS_REL32            3       /* PC relative 32 bit */
./include/api/elf.h:#define R_MIPS_26               4       /* Direct 26 bit shifted */
./include/api/elf.h:#define R_MIPS_HI16             5       /* High 16 bit */
./include/api/elf.h:#define R_MIPS_LO16             6       /* Low 16 bit */
./include/api/elf.h:#define R_MIPS_GPREL16          7       /* GP relative 16 bit */
./include/api/elf.h:#define R_MIPS_LITERAL          8       /* 16 bit literal entry */
./include/api/elf.h:#define R_MIPS_GOT16            9       /* 16 bit GOT entry */
./include/api/elf.h:#define R_MIPS_PC16             10      /* PC relative 16 bit */
./include/api/elf.h:#define R_MIPS_CALL16           11      /* 16 bit GOT entry for function */
./include/api/elf.h:#define R_MIPS_GPREL32          12      /* GP relative 32 bit */
./include/api/elf.h:#define R_MIPS_SHIFT5           16
./include/api/elf.h:#define R_MIPS_SHIFT6           17
./include/api/elf.h:#define R_MIPS_64               18
./include/api/elf.h:#define R_MIPS_GOT_DISP         19
./include/api/elf.h:#define R_MIPS_GOT_PAGE         20
./include/api/elf.h:#define R_MIPS_GOT_OFST         21
./include/api/elf.h:#define R_MIPS_GOT_HI16         22
./include/api/elf.h:#define R_MIPS_GOT_LO16         23
./include/api/elf.h:#define R_MIPS_SUB              24
./include/api/elf.h:#define R_MIPS_INSERT_A         25
./include/api/elf.h:#define R_MIPS_INSERT_B         26
./include/api/elf.h:#define R_MIPS_DELETE           27
./include/api/elf.h:#define R_MIPS_HIGHER           28
./include/api/elf.h:#define R_MIPS_HIGHEST          29
./include/api/elf.h:#define R_MIPS_CALL_HI16        30
./include/api/elf.h:#define R_MIPS_CALL_LO16        31
./include/api/elf.h:#define R_MIPS_SCN_DISP         32
./include/api/elf.h:#define R_MIPS_REL16            33
./include/api/elf.h:#define R_MIPS_ADD_IMMEDIATE    34
./include/api/elf.h:#define R_MIPS_PJUMP            35
./include/api/elf.h:#define R_MIPS_RELGOT           36
./include/api/elf.h:#define R_MIPS_JALR             37
./include/api/elf.h:#define R_MIPS_NUM              38
./include/api/elf.h:/* Legal values for p_type field of Elf32_Phdr.  */
./include/api/elf.h:#define PT_MIPS_REGINFO 0x70000000      /* Register usage information */
./include/api/elf.h:#define PT_MIPS_RTPROC  0x70000001      /* Runtime procedure table. */
./include/api/elf.h:#define PT_MIPS_OPTIONS 0x70000002
./include/api/elf.h:#define PF_MIPS_LOCAL   0x10000000
./include/api/elf.h:/* Legal values for d_tag field of Elf32_Dyn.  */
./include/api/elf.h:#define DT_MIPS_RLD_VERSION  0x70000001 /* Runtime linker interface version */
./include/api/elf.h:#define DT_MIPS_TIME_STAMP   0x70000002 /* Timestamp */
./include/api/elf.h:#define DT_MIPS_ICHECKSUM    0x70000003 /* Checksum */
./include/api/elf.h:#define DT_MIPS_IVERSION     0x70000004 /* Version string (string tbl index) */
./include/api/elf.h:#define DT_MIPS_FLAGS        0x70000005 /* Flags */
./include/api/elf.h:#define DT_MIPS_BASE_ADDRESS 0x70000006 /* Base address */
./include/api/elf.h:#define DT_MIPS_MSYM         0x70000007
./include/api/elf.h:#define DT_MIPS_CONFLICT     0x70000008 /* Address of CONFLICT section */
./include/api/elf.h:#define DT_MIPS_LIBLIST      0x70000009 /* Address of LIBLIST section */
./include/api/elf.h:#define DT_MIPS_LOCAL_GOTNO  0x7000000a /* Number of local GOT entries */
./include/api/elf.h:#define DT_MIPS_CONFLICTNO   0x7000000b /* Number of CONFLICT entries */
./include/api/elf.h:#define DT_MIPS_LIBLISTNO    0x70000010 /* Number of LIBLIST entries */
./include/api/elf.h:#define DT_MIPS_SYMTABNO     0x70000011 /* Number of DYNSYM entries */
./include/api/elf.h:#define DT_MIPS_UNREFEXTNO   0x70000012 /* First external DYNSYM */
./include/api/elf.h:#define DT_MIPS_GOTSYM       0x70000013 /* First GOT entry in DYNSYM */
./include/api/elf.h:#define DT_MIPS_HIPAGENO     0x70000014 /* Number of GOT page table entries */
./include/api/elf.h:#define DT_MIPS_RLD_MAP      0x70000016 /* Address of run time loader map.  */
./include/api/elf.h:#define DT_MIPS_DELTA_CLASS  0x70000017 /* Delta C++ class definition.  */
./include/api/elf.h:#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
./include/api/elf.h:#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
./include/api/elf.h:#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
./include/api/elf.h:#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
./include/api/elf.h:#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
./include/api/elf.h:#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
./include/api/elf.h:relocations refer to.  */
./include/api/elf.h:#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
./include/api/elf.h:#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
./include/api/elf.h:#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
./include/api/elf.h:#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
./include/api/elf.h:#define DT_MIPS_PIXIE_INIT   0x70000023
./include/api/elf.h:#define DT_MIPS_SYMBOL_LIB   0x70000024
./include/api/elf.h:#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
./include/api/elf.h:#define DT_MIPS_LOCAL_GOTIDX 0x70000026
./include/api/elf.h:#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
./include/api/elf.h:#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
./include/api/elf.h:#define DT_MIPS_OPTIONS      0x70000029 /* Address of .options.  */
./include/api/elf.h:#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
./include/api/elf.h:#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
./include/api/elf.h:#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
./include/api/elf.h:#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
./include/api/elf.h:        function stored in GOT.  */
./include/api/elf.h:#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
./include/api/elf.h:#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
./include/api/elf.h:#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
./include/api/elf.h:#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
./include/api/elf.h:#define DT_MIPS_NUM          0x32
./include/api/elf.h:/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
./include/api/elf.h:#define RHF_NONE                   0            /* No flags */
./include/api/elf.h:#define RHF_QUICKSTART             (1 << 0)     /* Use quickstart */
./include/api/elf.h:#define RHF_NOTPOT                 (1 << 1)     /* Hash size not power of 2 */
./include/api/elf.h:#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)     /* Ignore LD_LIBRARY_PATH */
./include/api/elf.h:#define RHF_NO_MOVE                (1 << 3)
./include/api/elf.h:#define RHF_SGI_ONLY               (1 << 4)
./include/api/elf.h:#define RHF_GUARANTEE_INIT         (1 << 5)
./include/api/elf.h:#define RHF_DELTA_C_PLUS_PLUS      (1 << 6)
./include/api/elf.h:#define RHF_GUARANTEE_START_INIT   (1 << 7)
./include/api/elf.h:#define RHF_PIXIE                  (1 << 8)
./include/api/elf.h:#define RHF_DEFAULT_DELAY_LOAD     (1 << 9)
./include/api/elf.h:#define RHF_REQUICKSTART           (1 << 10)
./include/api/elf.h:#define RHF_REQUICKSTARTED         (1 << 11)
./include/api/elf.h:#define RHF_CORD                   (1 << 12)
./include/api/elf.h:#define RHF_NO_UNRES_UNDEF         (1 << 13)
./include/api/elf.h:#define RHF_RLD_ORDER_SAFE         (1 << 14)
./include/api/elf.h:/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
./include/api/elf.h:                typedef struct {
./include/api/elf.h:                Elf32_Word l_name;            /* Name (string table index) */
./include/api/elf.h:                Elf32_Word l_time_stamp;      /* Timestamp */
./include/api/elf.h:                Elf32_Word l_checksum;        /* Checksum */
./include/api/elf.h:                Elf32_Word l_version;         /* Interface version */
./include/api/elf.h:                Elf32_Word l_flags;           /* Flags */
./include/api/elf.h:        } Elf32_Lib;
./include/api/elf.h:typedef struct {
./include/api/elf.h:        Elf64_Word l_name;            /* Name (string table index) */
./include/api/elf.h:        Elf64_Word l_time_stamp;      /* Timestamp */
./include/api/elf.h:        Elf64_Word l_checksum;        /* Checksum */
./include/api/elf.h:        Elf64_Word l_version;         /* Interface version */
./include/api/elf.h:        Elf64_Word l_flags;           /* Flags */
./include/api/elf.h:} Elf64_Lib;
./include/api/elf.h:/* Legal values for l_flags.  */
./include/api/elf.h:#define LL_NONE           0
./include/api/elf.h:#define LL_EXACT_MATCH    (1 << 0)      /* Require exact match */
./include/api/elf.h:#define LL_IGNORE_INT_VER (1 << 1)      /* Ignore interface version */
./include/api/elf.h:#define LL_REQUIRE_MINOR  (1 << 2)
./include/api/elf.h:#define LL_EXPORTS        (1 << 3)
./include/api/elf.h:#define LL_DELAY_LOAD     (1 << 4)
./include/api/elf.h:#define LL_DELTA          (1 << 5)
./include/api/elf.h:/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
./include/api/elf.h:typedef Elf32_Addr Elf32_Conflict;
./include/api/elf.h:/* HPPA specific definitions.  */
./include/api/elf.h:/* Legal values for e_flags field of Elf32_Ehdr.  */
./include/api/elf.h:#define EF_PARISC_TRAPNIL       0x00010000 /* Trap nil pointer dereference.  */
./include/api/elf.h:#define EF_PARISC_EXT           0x00020000 /* Program uses arch. extensions. */
./include/api/elf.h:#define EF_PARISC_LSB           0x00040000 /* Program expects little endian. */
./include/api/elf.h:#define EF_PARISC_WIDE          0x00080000 /* Program expects wide mode.  */
./include/api/elf.h:#define EF_PARISC_NO_KABP       0x00100000 /* No kernel assisted branch
./include/api/elf.h:#define EF_PARISC_LAZYSWAP      0x00400000 /* Allow lazy swapping.  */
./include/api/elf.h:#define EF_PARISC_ARCH          0x0000ffff /* Architecture version.  */
./include/api/elf.h:/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
./include/api/elf.h:#define EFA_PARISC_1_0              0x020b /* PA-RISC 1.0 big-endian.  */
./include/api/elf.h:#define EFA_PARISC_1_1              0x0210 /* PA-RISC 1.1 big-endian.  */
./include/api/elf.h:#define EFA_PARISC_2_0              0x0214 /* PA-RISC 2.0 big-endian.  */
./include/api/elf.h:#define SHN_PARISC_ANSI_COMMON  0xff00     /* Section for tenatively declared
./include/api/elf.h:#define SHN_PARISC_HUGE_COMMON  0xff01     /* Common blocks in huge model.  */
./include/api/elf.h:/* Legal values for sh_type field of Elf32_Shdr.  */
./include/api/elf.h:#define SHT_PARISC_EXT          0x70000000 /* Contains product specific ext. */
./include/api/elf.h:#define SHT_PARISC_UNWIND       0x70000001 /* Unwind information.  */
./include/api/elf.h:#define SHT_PARISC_DOC          0x70000002 /* Debug info for optimized code. */
./include/api/elf.h:/* Legal values for sh_flags field of Elf32_Shdr.  */
./include/api/elf.h:#define SHF_PARISC_SHORT        0x20000000 /* Section with short addressing. */
./include/api/elf.h:#define SHF_PARISC_HUGE         0x40000000 /* Section far from gp.  */
./include/api/elf.h:#define SHF_PARISC_SBP          0x80000000 /* Static branch prediction code. */
./include/api/elf.h:/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
./include/api/elf.h:#define STT_PARISC_MILLICODE    13      /* Millicode function entry point.  */
./include/api/elf.h:#define STT_HP_OPAQUE           (STT_LOOS + 0x1)
./include/api/elf.h:#define STT_HP_STUB             (STT_LOOS + 0x2)
./include/api/elf.h:#define R_PARISC_NONE           0       /* No reloc.  */
./include/api/elf.h:#define R_PARISC_DIR32          1       /* Direct 32-bit reference.  */
./include/api/elf.h:#define R_PARISC_DIR21L         2       /* Left 21 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR17R         3       /* Right 17 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR17F         4       /* 17 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR14R         6       /* Right 14 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_PCREL32        9       /* 32-bit rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL21L       10      /* Left 21 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL17R       11      /* Right 17 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL17F       12      /* 17 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL14R       14      /* Right 14 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_DPREL21L       18      /* Left 21 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_DPREL14R       22      /* Right 14 bits of rel. address.  */
./include/api/elf.h:#define R_PARISC_GPREL21L       26      /* GP-relative, left 21 bits.  */
./include/api/elf.h:#define R_PARISC_GPREL14R       30      /* GP-relative, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF21L       34      /* LT-relative, left 21 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF14R       38      /* LT-relative, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_SECREL32       41      /* 32 bits section rel. address.  */
./include/api/elf.h:#define R_PARISC_SEGBASE        48      /* No relocation, set segment base.  */
./include/api/elf.h:#define R_PARISC_SEGREL32       49      /* 32 bits segment rel. address.  */
./include/api/elf.h:#define R_PARISC_PLTOFF21L      50      /* PLT rel. address, left 21 bits.  */
./include/api/elf.h:#define R_PARISC_PLTOFF14R      54      /* PLT rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR32   57      /* 32 bits LT-rel. function pointer. */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR21L  58      /* LT-rel. fct ptr, left 21 bits. */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR14R  62      /* LT-rel. fct ptr, right 14 bits. */
./include/api/elf.h:#define R_PARISC_FPTR64         64      /* 64 bits function address.  */
./include/api/elf.h:#define R_PARISC_PLABEL32       65      /* 32 bits function address.  */
./include/api/elf.h:#define R_PARISC_PLABEL21L      66      /* Left 21 bits of fct ptr.  */
./include/api/elf.h:#define R_PARISC_PLABEL14R      70      /* Left 21 bits of fct ptr.  */
./include/api/elf.h:#define R_PARISC_PCREL64        72      /* 64 bits PC-rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL22F       74      /* 22 bits PC-rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL14WR      75      /* PC-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_PCREL14DR      76      /* PC rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_PCREL16F       77      /* 16 bits PC-rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL16WF      78      /* 16 bits PC-rel. address.  */
./include/api/elf.h:#define R_PARISC_PCREL16DF      79      /* 16 bits PC-rel. address.  */
./include/api/elf.h:#define R_PARISC_DIR64          80      /* 64 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR14WR        83      /* 14 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR14DR        84      /* 14 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR16F         85      /* 16 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR16WF        86      /* 16 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_DIR16DF        87      /* 16 bits of eff. address.  */
./include/api/elf.h:#define R_PARISC_GPREL64        88      /* 64 bits of GP-rel. address.  */
./include/api/elf.h:#define R_PARISC_GPREL14WR      91      /* GP-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_GPREL14DR      92      /* GP-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_GPREL16F       93      /* 16 bits GP-rel. address.  */
./include/api/elf.h:#define R_PARISC_GPREL16WF      94      /* 16 bits GP-rel. address.  */
./include/api/elf.h:#define R_PARISC_GPREL16DF      95      /* 16 bits GP-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF64        96      /* 64 bits LT-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF14WR      99      /* LT-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF14DR      100     /* LT-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF16F       101     /* 16 bits LT-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF16WF      102     /* 16 bits LT-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF16DF      103     /* 16 bits LT-rel. address.  */
./include/api/elf.h:#define R_PARISC_SECREL64       104     /* 64 bits section rel. address.  */
./include/api/elf.h:#define R_PARISC_SEGREL64       112     /* 64 bits segment rel. address.  */
./include/api/elf.h:#define R_PARISC_PLTOFF14WR     115     /* PLT-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_PLTOFF14DR     116     /* PLT-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_PLTOFF16F      117     /* 16 bits LT-rel. address.  */
./include/api/elf.h:#define R_PARISC_PLTOFF16WF     118     /* 16 bits PLT-rel. address.  */
./include/api/elf.h:#define R_PARISC_PLTOFF16DF     119     /* 16 bits PLT-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR64   120     /* 64 bits LT-rel. function ptr.  */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR14WR 123     /* LT-rel. fct. ptr., right 14 bits. */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR14DR 124     /* LT-rel. fct. ptr., right 14 bits. */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR16F  125     /* 16 bits LT-rel. function ptr.  */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR16WF 126     /* 16 bits LT-rel. function ptr.  */
./include/api/elf.h:#define R_PARISC_LTOFF_FPTR16DF 127     /* 16 bits LT-rel. function ptr.  */
./include/api/elf.h:#define R_PARISC_LORESERVE      128
./include/api/elf.h:#define R_PARISC_COPY           128     /* Copy relocation.  */
./include/api/elf.h:#define R_PARISC_IPLT           129     /* Dynamic reloc, imported PLT */
./include/api/elf.h:#define R_PARISC_EPLT           130     /* Dynamic reloc, exported PLT */
./include/api/elf.h:#define R_PARISC_TPREL32        153     /* 32 bits TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_TPREL21L       154     /* TP-rel. address, left 21 bits.  */
./include/api/elf.h:#define R_PARISC_TPREL14R       158     /* TP-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_LTOFF_TP21L    162     /* LT-TP-rel. address, left 21 bits. */
./include/api/elf.h:#define R_PARISC_LTOFF_TP14R    166     /* LT-TP-rel. address, right 14 bits.*/
./include/api/elf.h:#define R_PARISC_LTOFF_TP14F    167     /* 14 bits LT-TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_TPREL64        216     /* 64 bits TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_TPREL14WR      219     /* TP-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_TPREL14DR      220     /* TP-rel. address, right 14 bits.  */
./include/api/elf.h:#define R_PARISC_TPREL16F       221     /* 16 bits TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_TPREL16WF      222     /* 16 bits TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_TPREL16DF      223     /* 16 bits TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF_TP64     224     /* 64 bits LT-TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF_TP14WR   227     /* LT-TP-rel. address, right 14 bits.*/
./include/api/elf.h:#define R_PARISC_LTOFF_TP14DR   228     /* LT-TP-rel. address, right 14 bits.*/
./include/api/elf.h:#define R_PARISC_LTOFF_TP16F    229     /* 16 bits LT-TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF_TP16WF   230     /* 16 bits LT-TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_LTOFF_TP16DF   231     /* 16 bits LT-TP-rel. address.  */
./include/api/elf.h:#define R_PARISC_HIRESERVE      255
./include/api/elf.h:/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
./include/api/elf.h:#define PT_HP_TLS               (PT_LOOS + 0x0)
./include/api/elf.h:#define PT_HP_CORE_NONE         (PT_LOOS + 0x1)
./include/api/elf.h:#define PT_HP_CORE_VERSION      (PT_LOOS + 0x2)
./include/api/elf.h:#define PT_HP_CORE_KERNEL       (PT_LOOS + 0x3)
./include/api/elf.h:#define PT_HP_CORE_COMM         (PT_LOOS + 0x4)
./include/api/elf.h:#define PT_HP_CORE_PROC         (PT_LOOS + 0x5)
./include/api/elf.h:#define PT_HP_CORE_LOADABLE     (PT_LOOS + 0x6)
./include/api/elf.h:#define PT_HP_CORE_STACK        (PT_LOOS + 0x7)
./include/api/elf.h:#define PT_HP_CORE_SHM          (PT_LOOS + 0x8)
./include/api/elf.h:#define PT_HP_CORE_MMF          (PT_LOOS + 0x9)
./include/api/elf.h:#define PT_HP_PARALLEL          (PT_LOOS + 0x10)
./include/api/elf.h:#define PT_HP_FASTBIND          (PT_LOOS + 0x11)
./include/api/elf.h:#define PT_HP_OPT_ANNOT         (PT_LOOS + 0x12)
./include/api/elf.h:#define PT_HP_HSL_ANNOT         (PT_LOOS + 0x13)
./include/api/elf.h:#define PT_HP_STACK             (PT_LOOS + 0x14)
./include/api/elf.h:#define PT_PARISC_ARCHEXT       0x70000000
./include/api/elf.h:#define PT_PARISC_UNWIND        0x70000001
./include/api/elf.h:/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
./include/api/elf.h:#define PF_PARISC_SBP           0x08000000
./include/api/elf.h:#define PF_HP_PAGE_SIZE         0x00100000
./include/api/elf.h:#define PF_HP_FAR_SHARED        0x00200000
./include/api/elf.h:#define PF_HP_NEAR_SHARED       0x00400000
./include/api/elf.h:#define PF_HP_CODE              0x01000000
./include/api/elf.h:#define PF_HP_MODIFY            0x02000000
./include/api/elf.h:#define PF_HP_LAZYSWAP          0x04000000
./include/api/elf.h:#define PF_HP_SBP               0x08000000
./include/api/elf.h:/* Alpha specific definitions.  */
./include/api/elf.h:/* Legal values for e_flags field of Elf64_Ehdr.  */
./include/api/elf.h:#define EF_ALPHA_32BIT          1       /* All addresses must be < 2GB.  */
./include/api/elf.h:#define EF_ALPHA_CANRELAX       2       /* Relocations for relaxing exist.  */
./include/api/elf.h:/* Legal values for sh_type field of Elf64_Shdr.  */
./include/api/elf.h:/* These two are primerily concerned with ECOFF debugging info.  */
./include/api/elf.h:#define SHT_ALPHA_DEBUG         0x70000001
./include/api/elf.h:#define SHT_ALPHA_REGINFO       0x70000002
./include/api/elf.h:/* Legal values for sh_flags field of Elf64_Shdr.  */
./include/api/elf.h:#define SHF_ALPHA_GPREL         0x10000000
./include/api/elf.h:/* Legal values for st_other field of Elf64_Sym.  */
./include/api/elf.h:#define STO_ALPHA_NOPV          0x80    /* No PV required.  */
./include/api/elf.h:#define STO_ALPHA_STD_GPLOAD    0x88    /* PV only used for initial ldgp.  */
./include/api/elf.h:#define R_ALPHA_NONE            0       /* No reloc */
./include/api/elf.h:#define R_ALPHA_REFLONG         1       /* Direct 32 bit */
./include/api/elf.h:#define R_ALPHA_REFQUAD         2       /* Direct 64 bit */
./include/api/elf.h:#define R_ALPHA_GPREL32         3       /* GP relative 32 bit */
./include/api/elf.h:#define R_ALPHA_LITERAL         4       /* GP relative 16 bit w/optimization */
./include/api/elf.h:#define R_ALPHA_LITUSE          5       /* Optimization hint for LITERAL */
./include/api/elf.h:#define R_ALPHA_GPDISP          6       /* Add displacement to GP */
./include/api/elf.h:#define R_ALPHA_BRADDR          7       /* PC+4 relative 23 bit shifted */
./include/api/elf.h:#define R_ALPHA_HINT            8       /* PC+4 relative 16 bit shifted */
./include/api/elf.h:#define R_ALPHA_SREL16          9       /* PC relative 16 bit */
./include/api/elf.h:#define R_ALPHA_SREL32          10      /* PC relative 32 bit */
./include/api/elf.h:#define R_ALPHA_SREL64          11      /* PC relative 64 bit */
./include/api/elf.h:#define R_ALPHA_GPRELHIGH       17      /* GP relative 32 bit, high 16 bits */
./include/api/elf.h:#define R_ALPHA_GPRELLOW        18      /* GP relative 32 bit, low 16 bits */
./include/api/elf.h:#define R_ALPHA_GPREL16         19      /* GP relative 16 bit */
./include/api/elf.h:#define R_ALPHA_COPY            24      /* Copy symbol at runtime */
./include/api/elf.h:#define R_ALPHA_GLOB_DAT        25      /* Create GOT entry */
./include/api/elf.h:#define R_ALPHA_JMP_SLOT        26      /* Create PLT entry */
./include/api/elf.h:#define R_ALPHA_RELATIVE        27      /* Adjust by program base */
./include/api/elf.h:#define R_ALPHA_TLS_GD_HI       28
./include/api/elf.h:#define R_ALPHA_TLSGD           29
./include/api/elf.h:#define R_ALPHA_TLS_LDM         30
./include/api/elf.h:#define R_ALPHA_DTPMOD64        31
./include/api/elf.h:#define R_ALPHA_GOTDTPREL       32
./include/api/elf.h:#define R_ALPHA_DTPREL64        33
./include/api/elf.h:#define R_ALPHA_DTPRELHI        34
./include/api/elf.h:#define R_ALPHA_DTPRELLO        35
./include/api/elf.h:#define R_ALPHA_DTPREL16        36
./include/api/elf.h:#define R_ALPHA_GOTTPREL        37
./include/api/elf.h:#define R_ALPHA_TPREL64         38
./include/api/elf.h:#define R_ALPHA_TPRELHI         39
./include/api/elf.h:#define R_ALPHA_TPRELLO         40
./include/api/elf.h:#define R_ALPHA_TPREL16         41
./include/api/elf.h:#define R_ALPHA_NUM             46
./include/api/elf.h:/* Magic values of the LITUSE relocation addend.  */
./include/api/elf.h:#define LITUSE_ALPHA_ADDR       0
./include/api/elf.h:#define LITUSE_ALPHA_BASE       1
./include/api/elf.h:#define LITUSE_ALPHA_BYTOFF     2
./include/api/elf.h:#define LITUSE_ALPHA_JSR        3
./include/api/elf.h:#define LITUSE_ALPHA_TLS_GD     4
./include/api/elf.h:#define LITUSE_ALPHA_TLS_LDM    5
./include/api/elf.h:/* PowerPC specific declarations */
./include/api/elf.h:/* Values for Elf32/64_Ehdr.e_flags.  */
./include/api/elf.h:#define EF_PPC_EMB              0x80000000      /* PowerPC embedded flag */
./include/api/elf.h:#define EF_PPC_RELOCATABLE      0x00010000      /* PowerPC -mrelocatable flag*/
./include/api/elf.h:#define EF_PPC_RELOCATABLE_LIB  0x00008000      /* PowerPC -mrelocatable-lib
./include/api/elf.h:flag */
./include/api/elf.h:/* PowerPC relocations defined by the ABIs */
./include/api/elf.h:#define R_PPC_NONE              0
./include/api/elf.h:#define R_PPC_ADDR32            1       /* 32bit absolute address */
./include/api/elf.h:#define R_PPC_ADDR24            2       /* 26bit address, 2 bits ignored.  */
./include/api/elf.h:#define R_PPC_ADDR16            3       /* 16bit absolute address */
./include/api/elf.h:#define R_PPC_ADDR16_LO         4       /* lower 16bit of absolute address */
./include/api/elf.h:#define R_PPC_ADDR16_HI         5       /* high 16bit of absolute address */
./include/api/elf.h:#define R_PPC_ADDR16_HA         6       /* adjusted high 16bit */
./include/api/elf.h:#define R_PPC_ADDR14            7       /* 16bit address, 2 bits ignored */
./include/api/elf.h:#define R_PPC_ADDR14_BRTAKEN    8
./include/api/elf.h:#define R_PPC_ADDR14_BRNTAKEN   9
./include/api/elf.h:#define R_PPC_REL24             10      /* PC relative 26 bit */
./include/api/elf.h:#define R_PPC_REL14             11      /* PC relative 16 bit */
./include/api/elf.h:#define R_PPC_REL14_BRTAKEN     12
./include/api/elf.h:#define R_PPC_REL14_BRNTAKEN    13
./include/api/elf.h:#define R_PPC_GOT16             14
./include/api/elf.h:#define R_PPC_GOT16_LO          15
./include/api/elf.h:#define R_PPC_GOT16_HI          16
./include/api/elf.h:#define R_PPC_GOT16_HA          17
./include/api/elf.h:#define R_PPC_PLTREL24          18
./include/api/elf.h:#define R_PPC_COPY              19
./include/api/elf.h:#define R_PPC_GLOB_DAT          20
./include/api/elf.h:#define R_PPC_JMP_SLOT          21
./include/api/elf.h:#define R_PPC_RELATIVE          22
./include/api/elf.h:#define R_PPC_LOCAL24PC         23
./include/api/elf.h:#define R_PPC_UADDR32           24
./include/api/elf.h:#define R_PPC_UADDR16           25
./include/api/elf.h:#define R_PPC_REL32             26
./include/api/elf.h:#define R_PPC_PLT32             27
./include/api/elf.h:#define R_PPC_PLTREL32          28
./include/api/elf.h:#define R_PPC_PLT16_LO          29
./include/api/elf.h:#define R_PPC_PLT16_HI          30
./include/api/elf.h:#define R_PPC_PLT16_HA          31
./include/api/elf.h:#define R_PPC_SDAREL16          32
./include/api/elf.h:#define R_PPC_SECTOFF           33
./include/api/elf.h:#define R_PPC_SECTOFF_LO        34
./include/api/elf.h:#define R_PPC_SECTOFF_HI        35
./include/api/elf.h:#define R_PPC_SECTOFF_HA        36
./include/api/elf.h:/* PowerPC relocations defined for the TLS access ABI.  */
./include/api/elf.h:#define R_PPC_TLS               67 /* none      (sym+add)@tls */
./include/api/elf.h:#define R_PPC_DTPMOD32          68 /* word32    (sym+add)@dtpmod */
./include/api/elf.h:#define R_PPC_TPREL16           69 /* half16*   (sym+add)@tprel */
./include/api/elf.h:#define R_PPC_TPREL16_LO        70 /* half16    (sym+add)@tprel@l */
./include/api/elf.h:#define R_PPC_TPREL16_HI        71 /* half16    (sym+add)@tprel@h */
./include/api/elf.h:#define R_PPC_TPREL16_HA        72 /* half16    (sym+add)@tprel@ha */
./include/api/elf.h:#define R_PPC_TPREL32           73 /* word32    (sym+add)@tprel */
./include/api/elf.h:#define R_PPC_DTPREL16          74 /* half16*   (sym+add)@dtprel */
./include/api/elf.h:#define R_PPC_DTPREL16_LO       75 /* half16    (sym+add)@dtprel@l */
./include/api/elf.h:#define R_PPC_DTPREL16_HI       76 /* half16    (sym+add)@dtprel@h */
./include/api/elf.h:#define R_PPC_DTPREL16_HA       77 /* half16    (sym+add)@dtprel@ha */
./include/api/elf.h:#define R_PPC_DTPREL32          78 /* word32    (sym+add)@dtprel */
./include/api/elf.h:#define R_PPC_GOT_TLSGD16       79 /* half16*   (sym+add)@got@tlsgd */
./include/api/elf.h:#define R_PPC_GOT_TLSGD16_LO    80 /* half16    (sym+add)@got@tlsgd@l */
./include/api/elf.h:#define R_PPC_GOT_TLSGD16_HI    81 /* half16    (sym+add)@got@tlsgd@h */
./include/api/elf.h:#define R_PPC_GOT_TLSGD16_HA    82 /* half16    (sym+add)@got@tlsgd@ha */
./include/api/elf.h:#define R_PPC_GOT_TLSLD16       83 /* half16*   (sym+add)@got@tlsld */
./include/api/elf.h:#define R_PPC_GOT_TLSLD16_LO    84 /* half16    (sym+add)@got@tlsld@l */
./include/api/elf.h:#define R_PPC_GOT_TLSLD16_HI    85 /* half16    (sym+add)@got@tlsld@h */
./include/api/elf.h:#define R_PPC_GOT_TLSLD16_HA    86 /* half16    (sym+add)@got@tlsld@ha */
./include/api/elf.h:#define R_PPC_GOT_TPREL16       87 /* half16*   (sym+add)@got@tprel */
./include/api/elf.h:#define R_PPC_GOT_TPREL16_LO    88 /* half16    (sym+add)@got@tprel@l */
./include/api/elf.h:#define R_PPC_GOT_TPREL16_HI    89 /* half16    (sym+add)@got@tprel@h */
./include/api/elf.h:#define R_PPC_GOT_TPREL16_HA    90 /* half16    (sym+add)@got@tprel@ha */
./include/api/elf.h:#define R_PPC_GOT_DTPREL16      91 /* half16*   (sym+add)@got@dtprel */
./include/api/elf.h:#define R_PPC_GOT_DTPREL16_LO   92 /* half16*   (sym+add)@got@dtprel@l */
./include/api/elf.h:#define R_PPC_GOT_DTPREL16_HI   93 /* half16*   (sym+add)@got@dtprel@h */
./include/api/elf.h:#define R_PPC_GOT_DTPREL16_HA   94 /* half16*   (sym+add)@got@dtprel@ha */
./include/api/elf.h:#define R_PPC_NUM               95
./include/api/elf.h:/* The remaining relocs are from the Embedded ELF ABI, and are not
./include/api/elf.h:#define R_PPC_EMB_NADDR32       101
./include/api/elf.h:#define R_PPC_EMB_NADDR16       102
./include/api/elf.h:#define R_PPC_EMB_NADDR16_LO    103
./include/api/elf.h:#define R_PPC_EMB_NADDR16_HI    104
./include/api/elf.h:#define R_PPC_EMB_NADDR16_HA    105
./include/api/elf.h:#define R_PPC_EMB_SDAI16        106
./include/api/elf.h:#define R_PPC_EMB_SDA2I16       107
./include/api/elf.h:#define R_PPC_EMB_SDA2REL       108
./include/api/elf.h:#define R_PPC_EMB_SDA21         109     /* 16 bit offset in SDA */
./include/api/elf.h:#define R_PPC_EMB_MRKREF        110
./include/api/elf.h:#define R_PPC_EMB_RELSEC16      111
./include/api/elf.h:#define R_PPC_EMB_RELST_LO      112
./include/api/elf.h:#define R_PPC_EMB_RELST_HI      113
./include/api/elf.h:#define R_PPC_EMB_RELST_HA      114
./include/api/elf.h:#define R_PPC_EMB_BIT_FLD       115
./include/api/elf.h:#define R_PPC_EMB_RELSDA        116     /* 16 bit relative offset in SDA */
./include/api/elf.h:#define R_PPC_DIAB_SDA21_LO     180     /* like EMB_SDA21, but lower 16 bit */
./include/api/elf.h:#define R_PPC_DIAB_SDA21_HI     181     /* like EMB_SDA21, but high 16 bit */
./include/api/elf.h:#define R_PPC_DIAB_SDA21_HA     182     /* like EMB_SDA21, adjusted high 16 */
./include/api/elf.h:#define R_PPC_DIAB_RELSDA_LO    183     /* like EMB_RELSDA, but lower 16 bit */
./include/api/elf.h:#define R_PPC_DIAB_RELSDA_HI    184     /* like EMB_RELSDA, but high 16 bit */
./include/api/elf.h:#define R_PPC_DIAB_RELSDA_HA    185     /* like EMB_RELSDA, adjusted high 16 */
./include/api/elf.h:/* This is a phony reloc to handle any old fashioned TOC16 references
./include/api/elf.h:   that may still be in object files.  */
./include/api/elf.h:#define R_PPC_TOC16             255
./include/api/elf.h:/* PowerPC64 relocations defined by the ABIs */
./include/api/elf.h:#define R_PPC64_NONE            R_PPC_NONE
./include/api/elf.h:#define R_PPC64_ADDR32          R_PPC_ADDR32 /* 32bit absolute address */
./include/api/elf.h:#define R_PPC64_ADDR24          R_PPC_ADDR24 /* 26bit address, word aligned */
./include/api/elf.h:#define R_PPC64_ADDR16          R_PPC_ADDR16 /* 16bit absolute address */
./include/api/elf.h:#define R_PPC64_ADDR16_LO       R_PPC_ADDR16_LO /* lower 16bits of address */
./include/api/elf.h:#define R_PPC64_ADDR16_HI       R_PPC_ADDR16_HI /* high 16bits of address. */
./include/api/elf.h:#define R_PPC64_ADDR16_HA       R_PPC_ADDR16_HA /* adjusted high 16bits.  */
./include/api/elf.h:#define R_PPC64_ADDR14          R_PPC_ADDR14 /* 16bit address, word aligned */
./include/api/elf.h:#define R_PPC64_ADDR14_BRTAKEN  R_PPC_ADDR14_BRTAKEN
./include/api/elf.h:#define R_PPC64_ADDR14_BRNTAKEN R_PPC_ADDR14_BRNTAKEN
./include/api/elf.h:#define R_PPC64_REL24           R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
./include/api/elf.h:#define R_PPC64_REL14           R_PPC_REL14 /* PC relative 16 bit */
./include/api/elf.h:#define R_PPC64_REL14_BRTAKEN   R_PPC_REL14_BRTAKEN
./include/api/elf.h:#define R_PPC64_REL14_BRNTAKEN  R_PPC_REL14_BRNTAKEN
./include/api/elf.h:#define R_PPC64_GOT16           R_PPC_GOT16
./include/api/elf.h:#define R_PPC64_GOT16_LO        R_PPC_GOT16_LO
./include/api/elf.h:#define R_PPC64_GOT16_HI        R_PPC_GOT16_HI
./include/api/elf.h:#define R_PPC64_GOT16_HA        R_PPC_GOT16_HA
./include/api/elf.h:#define R_PPC64_COPY            R_PPC_COPY
./include/api/elf.h:#define R_PPC64_GLOB_DAT        R_PPC_GLOB_DAT
./include/api/elf.h:#define R_PPC64_JMP_SLOT        R_PPC_JMP_SLOT
./include/api/elf.h:#define R_PPC64_RELATIVE        R_PPC_RELATIVE
./include/api/elf.h:#define R_PPC64_UADDR32         R_PPC_UADDR32
./include/api/elf.h:#define R_PPC64_UADDR16         R_PPC_UADDR16
./include/api/elf.h:#define R_PPC64_REL32           R_PPC_REL32
./include/api/elf.h:#define R_PPC64_PLT32           R_PPC_PLT32
./include/api/elf.h:#define R_PPC64_PLTREL32        R_PPC_PLTREL32
./include/api/elf.h:#define R_PPC64_PLT16_LO        R_PPC_PLT16_LO
./include/api/elf.h:#define R_PPC64_PLT16_HI        R_PPC_PLT16_HI
./include/api/elf.h:#define R_PPC64_PLT16_HA        R_PPC_PLT16_HA
./include/api/elf.h:#define R_PPC64_SECTOFF         R_PPC_SECTOFF
./include/api/elf.h:#define R_PPC64_SECTOFF_LO      R_PPC_SECTOFF_LO
./include/api/elf.h:#define R_PPC64_SECTOFF_HI      R_PPC_SECTOFF_HI
./include/api/elf.h:#define R_PPC64_SECTOFF_HA      R_PPC_SECTOFF_HA
./include/api/elf.h:#define R_PPC64_ADDR30          37 /* word30 (S + A - P) >> 2 */
./include/api/elf.h:#define R_PPC64_ADDR64          38 /* doubleword64 S + A */
./include/api/elf.h:#define R_PPC64_ADDR16_HIGHER   39 /* half16 #higher(S + A) */
./include/api/elf.h:#define R_PPC64_ADDR16_HIGHERA  40 /* half16 #highera(S + A) */
./include/api/elf.h:#define R_PPC64_ADDR16_HIGHEST  41 /* half16 #highest(S + A) */
./include/api/elf.h:#define R_PPC64_ADDR16_HIGHESTA 42 /* half16 #highesta(S + A) */
./include/api/elf.h:#define R_PPC64_UADDR64         43 /* doubleword64 S + A */
./include/api/elf.h:#define R_PPC64_REL64           44 /* doubleword64 S + A - P */
./include/api/elf.h:#define R_PPC64_PLT64           45 /* doubleword64 L + A */
./include/api/elf.h:#define R_PPC64_PLTREL64        46 /* doubleword64 L + A - P */
./include/api/elf.h:#define R_PPC64_TOC16           47 /* half16* S + A - .TOC */
./include/api/elf.h:#define R_PPC64_TOC16_LO        48 /* half16 #lo(S + A - .TOC.) */
./include/api/elf.h:#define R_PPC64_TOC16_HI        49 /* half16 #hi(S + A - .TOC.) */
./include/api/elf.h:#define R_PPC64_TOC16_HA        50 /* half16 #ha(S + A - .TOC.) */
./include/api/elf.h:#define R_PPC64_TOC             51 /* doubleword64 .TOC */
./include/api/elf.h:#define R_PPC64_PLTGOT16        52 /* half16* M + A */
./include/api/elf.h:#define R_PPC64_PLTGOT16_LO     53 /* half16 #lo(M + A) */
./include/api/elf.h:#define R_PPC64_PLTGOT16_HI     54 /* half16 #hi(M + A) */
./include/api/elf.h:#define R_PPC64_PLTGOT16_HA     55 /* half16 #ha(M + A) */
./include/api/elf.h:#define R_PPC64_ADDR16_DS       56 /* half16ds* (S + A) >> 2 */
./include/api/elf.h:#define R_PPC64_ADDR16_LO_DS    57 /* half16ds  #lo(S + A) >> 2 */
./include/api/elf.h:#define R_PPC64_GOT16_DS        58 /* half16ds* (G + A) >> 2 */
./include/api/elf.h:#define R_PPC64_GOT16_LO_DS     59 /* half16ds  #lo(G + A) >> 2 */
./include/api/elf.h:#define R_PPC64_PLT16_LO_DS     60 /* half16ds  #lo(L + A) >> 2 */
./include/api/elf.h:#define R_PPC64_SECTOFF_DS      61 /* half16ds* (R + A) >> 2 */
./include/api/elf.h:#define R_PPC64_SECTOFF_LO_DS   62 /* half16ds  #lo(R + A) >> 2 */
./include/api/elf.h:#define R_PPC64_TOC16_DS        63 /* half16ds* (S + A - .TOC.) >> 2 */
./include/api/elf.h:#define R_PPC64_TOC16_LO_DS     64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
./include/api/elf.h:#define R_PPC64_PLTGOT16_DS     65 /* half16ds* (M + A) >> 2 */
./include/api/elf.h:#define R_PPC64_PLTGOT16_LO_DS  66 /* half16ds  #lo(M + A) >> 2 */
./include/api/elf.h:/* PowerPC64 relocations defined for the TLS access ABI.  */
./include/api/elf.h:#define R_PPC64_TLS             67 /* none      (sym+add)@tls */
./include/api/elf.h:#define R_PPC64_DTPMOD64        68 /* doubleword64 (sym+add)@dtpmod */
./include/api/elf.h:#define R_PPC64_TPREL16         69 /* half16*   (sym+add)@tprel */
./include/api/elf.h:#define R_PPC64_TPREL16_LO      70 /* half16    (sym+add)@tprel@l */
./include/api/elf.h:#define R_PPC64_TPREL16_HI      71 /* half16    (sym+add)@tprel@h */
./include/api/elf.h:#define R_PPC64_TPREL16_HA      72 /* half16    (sym+add)@tprel@ha */
./include/api/elf.h:#define R_PPC64_TPREL64         73 /* doubleword64 (sym+add)@tprel */
./include/api/elf.h:#define R_PPC64_DTPREL16        74 /* half16*   (sym+add)@dtprel */
./include/api/elf.h:#define R_PPC64_DTPREL16_LO     75 /* half16    (sym+add)@dtprel@l */
./include/api/elf.h:#define R_PPC64_DTPREL16_HI     76 /* half16    (sym+add)@dtprel@h */
./include/api/elf.h:#define R_PPC64_DTPREL16_HA     77 /* half16    (sym+add)@dtprel@ha */
./include/api/elf.h:#define R_PPC64_DTPREL64        78 /* doubleword64 (sym+add)@dtprel */
./include/api/elf.h:#define R_PPC64_GOT_TLSGD16     79 /* half16*   (sym+add)@got@tlsgd */
./include/api/elf.h:#define R_PPC64_GOT_TLSGD16_LO  80 /* half16    (sym+add)@got@tlsgd@l */
./include/api/elf.h:#define R_PPC64_GOT_TLSGD16_HI  81 /* half16    (sym+add)@got@tlsgd@h */
./include/api/elf.h:#define R_PPC64_GOT_TLSGD16_HA  82 /* half16    (sym+add)@got@tlsgd@ha */
./include/api/elf.h:#define R_PPC64_GOT_TLSLD16     83 /* half16*   (sym+add)@got@tlsld */
./include/api/elf.h:#define R_PPC64_GOT_TLSLD16_LO  84 /* half16    (sym+add)@got@tlsld@l */
./include/api/elf.h:#define R_PPC64_GOT_TLSLD16_HI  85 /* half16    (sym+add)@got@tlsld@h */
./include/api/elf.h:#define R_PPC64_GOT_TLSLD16_HA  86 /* half16    (sym+add)@got@tlsld@ha */
./include/api/elf.h:#define R_PPC64_GOT_TPREL16_DS  87 /* half16ds* (sym+add)@got@tprel */
./include/api/elf.h:#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
./include/api/elf.h:#define R_PPC64_GOT_TPREL16_HI  89 /* half16    (sym+add)@got@tprel@h */
./include/api/elf.h:#define R_PPC64_GOT_TPREL16_HA  90 /* half16    (sym+add)@got@tprel@ha */
./include/api/elf.h:#define R_PPC64_GOT_DTPREL16_DS 91 /* half16ds* (sym+add)@got@dtprel */
./include/api/elf.h:#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
./include/api/elf.h:#define R_PPC64_GOT_DTPREL16_HI 93 /* half16    (sym+add)@got@dtprel@h */
./include/api/elf.h:#define R_PPC64_GOT_DTPREL16_HA 94 /* half16    (sym+add)@got@dtprel@ha */
./include/api/elf.h:#define R_PPC64_TPREL16_DS      95 /* half16ds* (sym+add)@tprel */
./include/api/elf.h:#define R_PPC64_TPREL16_LO_DS   96 /* half16ds  (sym+add)@tprel@l */
./include/api/elf.h:#define R_PPC64_TPREL16_HIGHER  97 /* half16    (sym+add)@tprel@higher */
./include/api/elf.h:#define R_PPC64_TPREL16_HIGHERA 98 /* half16    (sym+add)@tprel@highera */
./include/api/elf.h:#define R_PPC64_TPREL16_HIGHEST 99 /* half16    (sym+add)@tprel@highest */
./include/api/elf.h:#define R_PPC64_TPREL16_HIGHESTA 100 /* half16  (sym+add)@tprel@highesta */
./include/api/elf.h:#define R_PPC64_DTPREL16_DS     101 /* half16ds* (sym+add)@dtprel */
./include/api/elf.h:#define R_PPC64_DTPREL16_LO_DS  102 /* half16ds (sym+add)@dtprel@l */
./include/api/elf.h:#define R_PPC64_DTPREL16_HIGHER 103 /* half16   (sym+add)@dtprel@higher */
./include/api/elf.h:#define R_PPC64_DTPREL16_HIGHERA 104 /* half16  (sym+add)@dtprel@highera */
./include/api/elf.h:#define R_PPC64_DTPREL16_HIGHEST 105 /* half16  (sym+add)@dtprel@highest */
./include/api/elf.h:#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16 (sym+add)@dtprel@highesta */
./include/api/elf.h:#define R_PPC64_NUM             107
./include/api/elf.h:/* PowerPC64 specific values for the Dyn d_tag field.  */
./include/api/elf.h:#define DT_PPC64_GLINK  (DT_LOPROC + 0)
./include/api/elf.h:#define DT_PPC64_OPD    (DT_LOPROC + 1)
./include/api/elf.h:#define DT_PPC64_OPDSZ  (DT_LOPROC + 2)
./include/api/elf.h:#define DT_PPC64_NUM    3
./include/api/elf.h:/* ARM specific declarations */
./include/api/elf.h:/* Processor specific flags for the ELF header e_flags field.  */
./include/api/elf.h:#define EF_ARM_RELEXEC     0x01
./include/api/elf.h:#define EF_ARM_HASENTRY    0x02
./include/api/elf.h:#define EF_ARM_INTERWORK   0x04
./include/api/elf.h:#define EF_ARM_APCS_26     0x08
./include/api/elf.h:#define EF_ARM_APCS_FLOAT  0x10
./include/api/elf.h:#define EF_ARM_PIC         0x20
./include/api/elf.h:#define EF_ARM_ALIGN8      0x40         /* 8-bit structure alignment is in use */
./include/api/elf.h:#define EF_ARM_NEW_ABI     0x80
./include/api/elf.h:#define EF_ARM_OLD_ABI     0x100
./include/api/elf.h:/* Other constants defined in the ARM ELF spec. version B-01.  */
./include/api/elf.h:/* NB. These conflict with values defined above.  */
./include/api/elf.h:#define EF_ARM_SYMSARESORTED    0x04
./include/api/elf.h:#define EF_ARM_DYNSYMSUSESEGIDX 0x08
./include/api/elf.h:#define EF_ARM_MAPSYMSFIRST     0x10
./include/api/elf.h:#define EF_ARM_EABIMASK         0XFF000000
./include/api/elf.h:#define EF_ARM_EABI_VERSION(flags) ((flags) & EF_ARM_EABIMASK)
./include/api/elf.h:#define EF_ARM_EABI_UNKNOWN  0x00000000
./include/api/elf.h:#define EF_ARM_EABI_VER1     0x01000000
./include/api/elf.h:#define EF_ARM_EABI_VER2     0x02000000
./include/api/elf.h:/* Additional symbol types for Thumb */
./include/api/elf.h:#define STT_ARM_TFUNC      0xd
./include/api/elf.h:/* ARM-specific values for sh_flags */
./include/api/elf.h:#define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry point */
./include/api/elf.h:#define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply defined
./include/api/elf.h:/* ARM-specific program header flags */
./include/api/elf.h:#define PF_ARM_SB          0x10000000   /* Segment contains the location
./include/api/elf.h:#define R_ARM_NONE              0       /* No reloc */
./include/api/elf.h:#define R_ARM_PC24              1       /* PC relative 26 bit branch */
./include/api/elf.h:#define R_ARM_ABS32             2       /* Direct 32 bit  */
./include/api/elf.h:#define R_ARM_REL32             3       /* PC relative 32 bit */
./include/api/elf.h:#define R_ARM_PC13              4
./include/api/elf.h:#define R_ARM_ABS16             5       /* Direct 16 bit */
./include/api/elf.h:#define R_ARM_ABS12             6       /* Direct 12 bit */
./include/api/elf.h:#define R_ARM_THM_ABS5          7
./include/api/elf.h:#define R_ARM_ABS8              8       /* Direct 8 bit */
./include/api/elf.h:#define R_ARM_SBREL32           9
./include/api/elf.h:#define R_ARM_THM_PC22          10
./include/api/elf.h:#define R_ARM_THM_PC8           11
./include/api/elf.h:#define R_ARM_AMP_VCALL9        12
./include/api/elf.h:#define R_ARM_SWI24             13
./include/api/elf.h:#define R_ARM_THM_SWI8          14
./include/api/elf.h:#define R_ARM_XPC25             15
./include/api/elf.h:#define R_ARM_THM_XPC22         16
./include/api/elf.h:#define R_ARM_COPY              20      /* Copy symbol at runtime */
./include/api/elf.h:#define R_ARM_GLOB_DAT          21      /* Create GOT entry */
./include/api/elf.h:#define R_ARM_JUMP_SLOT         22      /* Create PLT entry */
./include/api/elf.h:#define R_ARM_RELATIVE          23      /* Adjust by program base */
./include/api/elf.h:#define R_ARM_GOTOFF            24      /* 32 bit offset to GOT */
./include/api/elf.h:#define R_ARM_GOTPC             25      /* 32 bit PC relative offset to GOT */
./include/api/elf.h:#define R_ARM_GOT32             26      /* 32 bit GOT entry */
./include/api/elf.h:#define R_ARM_PLT32             27      /* 32 bit PLT address */
./include/api/elf.h:#define R_ARM_ALU_PCREL_7_0     32
./include/api/elf.h:#define R_ARM_ALU_PCREL_15_8    33
./include/api/elf.h:#define R_ARM_ALU_PCREL_23_15   34
./include/api/elf.h:#define R_ARM_LDR_SBREL_11_0    35
./include/api/elf.h:#define R_ARM_ALU_SBREL_19_12   36
./include/api/elf.h:#define R_ARM_ALU_SBREL_27_20   37
./include/api/elf.h:#define R_ARM_GNU_VTENTRY       100
./include/api/elf.h:#define R_ARM_GNU_VTINHERIT     101
./include/api/elf.h:#define R_ARM_THM_PC11          102     /* thumb unconditional branch */
./include/api/elf.h:#define R_ARM_THM_PC9           103     /* thumb conditional branch */
./include/api/elf.h:#define R_ARM_RXPC25            249
./include/api/elf.h:#define R_ARM_RSBREL32          250
./include/api/elf.h:#define R_ARM_THM_RPC22         251
./include/api/elf.h:#define R_ARM_RREL32            252
./include/api/elf.h:#define R_ARM_RABS22            253
./include/api/elf.h:#define R_ARM_RPC24             254
./include/api/elf.h:#define R_ARM_RBASE             255
./include/api/elf.h:#define R_ARM_NUM               256
./include/api/elf.h:/* IA-64 specific declarations.  */
./include/api/elf.h:/* Processor specific flags for the Ehdr e_flags field.  */
./include/api/elf.h:#define EF_IA_64_MASKOS         0x0000000f      /* os-specific flags */
./include/api/elf.h:#define EF_IA_64_ABI64          0x00000010      /* 64-bit ABI */
./include/api/elf.h:#define EF_IA_64_ARCH           0xff000000      /* arch. version mask */
./include/api/elf.h:/* Processor specific values for the Phdr p_type field.  */
./include/api/elf.h:#define PT_IA_64_ARCHEXT        (PT_LOPROC + 0) /* arch extension bits */
./include/api/elf.h:#define PT_IA_64_UNWIND         (PT_LOPROC + 1) /* ia64 unwind bits */
./include/api/elf.h:#define PT_IA_64_HP_OPT_ANOT    (PT_LOOS + 0x12)
./include/api/elf.h:#define PT_IA_64_HP_HSL_ANOT    (PT_LOOS + 0x13)
./include/api/elf.h:#define PT_IA_64_HP_STACK       (PT_LOOS + 0x14)
./include/api/elf.h:/* Processor specific flags for the Phdr p_flags field.  */
./include/api/elf.h:#define PF_IA_64_NORECOV        0x80000000      /* spec insns w/o recovery */
./include/api/elf.h:/* Processor specific values for the Shdr sh_type field.  */
./include/api/elf.h:#define SHT_IA_64_EXT           (SHT_LOPROC + 0) /* extension bits */
./include/api/elf.h:#define SHT_IA_64_UNWIND        (SHT_LOPROC + 1) /* unwind bits */
./include/api/elf.h:/* Processor specific flags for the Shdr sh_flags field.  */
./include/api/elf.h:#define SHF_IA_64_SHORT         0x10000000      /* section near gp */
./include/api/elf.h:#define SHF_IA_64_NORECOV       0x20000000      /* spec insns w/o recovery */
./include/api/elf.h:/* Processor specific values for the Dyn d_tag field.  */
./include/api/elf.h:#define DT_IA_64_PLT_RESERVE    (DT_LOPROC + 0)
./include/api/elf.h:#define DT_IA_64_NUM            1
./include/api/elf.h:#define R_IA64_NONE             0x00    /* none */
./include/api/elf.h:#define R_IA64_IMM14            0x21    /* symbol + addend, add imm14 */
./include/api/elf.h:#define R_IA64_IMM22            0x22    /* symbol + addend, add imm22 */
./include/api/elf.h:#define R_IA64_IMM64            0x23    /* symbol + addend, mov imm64 */
./include/api/elf.h:#define R_IA64_DIR32MSB         0x24    /* symbol + addend, data4 MSB */
./include/api/elf.h:#define R_IA64_DIR32LSB         0x25    /* symbol + addend, data4 LSB */
./include/api/elf.h:#define R_IA64_DIR64MSB         0x26    /* symbol + addend, data8 MSB */
./include/api/elf.h:#define R_IA64_DIR64LSB         0x27    /* symbol + addend, data8 LSB */
./include/api/elf.h:#define R_IA64_GPREL22          0x2a    /* @gprel(sym + add), add imm22 */
./include/api/elf.h:#define R_IA64_GPREL64I         0x2b    /* @gprel(sym + add), mov imm64 */
./include/api/elf.h:#define R_IA64_GPREL32MSB       0x2c    /* @gprel(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_GPREL32LSB       0x2d    /* @gprel(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_GPREL64MSB       0x2e    /* @gprel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_GPREL64LSB       0x2f    /* @gprel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_LTOFF22          0x32    /* @ltoff(sym + add), add imm22 */
./include/api/elf.h:#define R_IA64_LTOFF64I         0x33    /* @ltoff(sym + add), mov imm64 */
./include/api/elf.h:#define R_IA64_PLTOFF22         0x3a    /* @pltoff(sym + add), add imm22 */
./include/api/elf.h:#define R_IA64_PLTOFF64I        0x3b    /* @pltoff(sym + add), mov imm64 */
./include/api/elf.h:#define R_IA64_PLTOFF64MSB      0x3e    /* @pltoff(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_PLTOFF64LSB      0x3f    /* @pltoff(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_FPTR64I          0x43    /* @fptr(sym + add), mov imm64 */
./include/api/elf.h:#define R_IA64_FPTR32MSB        0x44    /* @fptr(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_FPTR32LSB        0x45    /* @fptr(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_FPTR64MSB        0x46    /* @fptr(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_FPTR64LSB        0x47    /* @fptr(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_PCREL60B         0x48    /* @pcrel(sym + add), brl */
./include/api/elf.h:#define R_IA64_PCREL21B         0x49    /* @pcrel(sym + add), ptb, call */
./include/api/elf.h:#define R_IA64_PCREL21M         0x4a    /* @pcrel(sym + add), chk.s */
./include/api/elf.h:#define R_IA64_PCREL21F         0x4b    /* @pcrel(sym + add), fchkf */
./include/api/elf.h:#define R_IA64_PCREL32MSB       0x4c    /* @pcrel(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_PCREL32LSB       0x4d    /* @pcrel(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_PCREL64MSB       0x4e    /* @pcrel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_PCREL64LSB       0x4f    /* @pcrel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR22     0x52    /* @ltoff(@fptr(s+a)), imm22 */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR64I    0x53    /* @ltoff(@fptr(s+a)), imm64 */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR32MSB  0x54    /* @ltoff(@fptr(s+a)), data4 MSB */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR32LSB  0x55    /* @ltoff(@fptr(s+a)), data4 LSB */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR64MSB  0x56    /* @ltoff(@fptr(s+a)), data8 MSB */
./include/api/elf.h:#define R_IA64_LTOFF_FPTR64LSB  0x57    /* @ltoff(@fptr(s+a)), data8 LSB */
./include/api/elf.h:#define R_IA64_SEGREL32MSB      0x5c    /* @segrel(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_SEGREL32LSB      0x5d    /* @segrel(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_SEGREL64MSB      0x5e    /* @segrel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_SEGREL64LSB      0x5f    /* @segrel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_SECREL32MSB      0x64    /* @secrel(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_SECREL32LSB      0x65    /* @secrel(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_SECREL64MSB      0x66    /* @secrel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_SECREL64LSB      0x67    /* @secrel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_REL32MSB         0x6c    /* data 4 + REL */
./include/api/elf.h:#define R_IA64_REL32LSB         0x6d    /* data 4 + REL */
./include/api/elf.h:#define R_IA64_REL64MSB         0x6e    /* data 8 + REL */
./include/api/elf.h:#define R_IA64_REL64LSB         0x6f    /* data 8 + REL */
./include/api/elf.h:#define R_IA64_LTV32MSB         0x74    /* symbol + addend, data4 MSB */
./include/api/elf.h:#define R_IA64_LTV32LSB         0x75    /* symbol + addend, data4 LSB */
./include/api/elf.h:#define R_IA64_LTV64MSB         0x76    /* symbol + addend, data8 MSB */
./include/api/elf.h:#define R_IA64_LTV64LSB         0x77    /* symbol + addend, data8 LSB */
./include/api/elf.h:#define R_IA64_PCREL21BI        0x79    /* @pcrel(sym + add), 21bit inst */
./include/api/elf.h:#define R_IA64_PCREL22          0x7a    /* @pcrel(sym + add), 22bit inst */
./include/api/elf.h:#define R_IA64_PCREL64I         0x7b    /* @pcrel(sym + add), 64bit inst */
./include/api/elf.h:#define R_IA64_IPLTMSB          0x80    /* dynamic reloc, imported PLT, MSB */
./include/api/elf.h:#define R_IA64_IPLTLSB          0x81    /* dynamic reloc, imported PLT, LSB */
./include/api/elf.h:#define R_IA64_COPY             0x84    /* copy relocation */
./include/api/elf.h:#define R_IA64_SUB              0x85    /* Addend and symbol difference */
./include/api/elf.h:#define R_IA64_LTOFF22X         0x86    /* LTOFF22, relaxable.  */
./include/api/elf.h:#define R_IA64_LDXMOV           0x87    /* Use of LTOFF22X.  */
./include/api/elf.h:#define R_IA64_TPREL14          0x91    /* @tprel(sym + add), imm14 */
./include/api/elf.h:#define R_IA64_TPREL22          0x92    /* @tprel(sym + add), imm22 */
./include/api/elf.h:#define R_IA64_TPREL64I         0x93    /* @tprel(sym + add), imm64 */
./include/api/elf.h:#define R_IA64_TPREL64MSB       0x96    /* @tprel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_TPREL64LSB       0x97    /* @tprel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_LTOFF_TPREL22    0x9a    /* @ltoff(@tprel(s+a)), imm2 */
./include/api/elf.h:#define R_IA64_DTPMOD64MSB      0xa6    /* @dtpmod(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_DTPMOD64LSB      0xa7    /* @dtpmod(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_LTOFF_DTPMOD22   0xaa    /* @ltoff(@dtpmod(sym + add)), imm22 */
./include/api/elf.h:#define R_IA64_DTPREL14         0xb1    /* @dtprel(sym + add), imm14 */
./include/api/elf.h:#define R_IA64_DTPREL22         0xb2    /* @dtprel(sym + add), imm22 */
./include/api/elf.h:#define R_IA64_DTPREL64I        0xb3    /* @dtprel(sym + add), imm64 */
./include/api/elf.h:#define R_IA64_DTPREL32MSB      0xb4    /* @dtprel(sym + add), data4 MSB */
./include/api/elf.h:#define R_IA64_DTPREL32LSB      0xb5    /* @dtprel(sym + add), data4 LSB */
./include/api/elf.h:#define R_IA64_DTPREL64MSB      0xb6    /* @dtprel(sym + add), data8 MSB */
./include/api/elf.h:#define R_IA64_DTPREL64LSB      0xb7    /* @dtprel(sym + add), data8 LSB */
./include/api/elf.h:#define R_IA64_LTOFF_DTPREL22   0xba    /* @ltoff(@dtprel(s+a)), imm22 */
./include/api/elf.h:/* SH specific declarations */
./include/api/elf.h:#define R_SH_NONE               0
./include/api/elf.h:#define R_SH_DIR32              1
./include/api/elf.h:#define R_SH_REL32              2
./include/api/elf.h:#define R_SH_DIR8WPN            3
./include/api/elf.h:#define R_SH_IND12W             4
./include/api/elf.h:#define R_SH_DIR8WPL            5
./include/api/elf.h:#define R_SH_DIR8WPZ            6
./include/api/elf.h:#define R_SH_DIR8BP             7
./include/api/elf.h:#define R_SH_DIR8W              8
./include/api/elf.h:#define R_SH_DIR8L              9
./include/api/elf.h:#define R_SH_SWITCH16           25
./include/api/elf.h:#define R_SH_SWITCH32           26
./include/api/elf.h:#define R_SH_USES               27
./include/api/elf.h:#define R_SH_COUNT              28
./include/api/elf.h:#define R_SH_ALIGN              29
./include/api/elf.h:#define R_SH_CODE               30
./include/api/elf.h:#define R_SH_DATA               31
./include/api/elf.h:#define R_SH_LABEL              32
./include/api/elf.h:#define R_SH_SWITCH8            33
./include/api/elf.h:#define R_SH_GNU_VTINHERIT      34
./include/api/elf.h:#define R_SH_GNU_VTENTRY        35
./include/api/elf.h:#define R_SH_TLS_GD_32          144
./include/api/elf.h:#define R_SH_TLS_LD_32          145
./include/api/elf.h:#define R_SH_TLS_LDO_32         146
./include/api/elf.h:#define R_SH_TLS_IE_32          147
./include/api/elf.h:#define R_SH_TLS_LE_32          148
./include/api/elf.h:#define R_SH_TLS_DTPMOD32       149
./include/api/elf.h:#define R_SH_TLS_DTPOFF32       150
./include/api/elf.h:#define R_SH_TLS_TPOFF32        151
./include/api/elf.h:#define R_SH_GOT32              160
./include/api/elf.h:#define R_SH_PLT32              161
./include/api/elf.h:#define R_SH_COPY               162
./include/api/elf.h:#define R_SH_GLOB_DAT           163
./include/api/elf.h:#define R_SH_JMP_SLOT           164
./include/api/elf.h:#define R_SH_RELATIVE           165
./include/api/elf.h:#define R_SH_GOTOFF             166
./include/api/elf.h:#define R_SH_GOTPC              167
./include/api/elf.h:#define R_SH_NUM                256
./include/api/elf.h:#define R_390_NONE              0       /* No reloc.  */
./include/api/elf.h:#define R_390_8                 1       /* Direct 8 bit.  */
./include/api/elf.h:#define R_390_12                2       /* Direct 12 bit.  */
./include/api/elf.h:#define R_390_16                3       /* Direct 16 bit.  */
./include/api/elf.h:#define R_390_32                4       /* Direct 32 bit.  */
./include/api/elf.h:#define R_390_PC32              5       /* PC relative 32 bit.  */
./include/api/elf.h:#define R_390_GOT12             6       /* 12 bit GOT offset.  */
./include/api/elf.h:#define R_390_GOT32             7       /* 32 bit GOT offset.  */
./include/api/elf.h:#define R_390_PLT32             8       /* 32 bit PC relative PLT address.  */
./include/api/elf.h:#define R_390_COPY              9       /* Copy symbol at runtime.  */
./include/api/elf.h:#define R_390_GLOB_DAT          10      /* Create GOT entry.  */
./include/api/elf.h:#define R_390_JMP_SLOT          11      /* Create PLT entry.  */
./include/api/elf.h:#define R_390_RELATIVE          12      /* Adjust by program base.  */
./include/api/elf.h:#define R_390_GOTOFF32          13      /* 32 bit offset to GOT.         */
./include/api/elf.h:#define R_390_GOTPC             14      /* 32 bit PC relative offset to GOT.  */
./include/api/elf.h:#define R_390_GOT16             15      /* 16 bit GOT offset.  */
./include/api/elf.h:#define R_390_PC16              16      /* PC relative 16 bit.  */
./include/api/elf.h:#define R_390_PC16DBL           17      /* PC relative 16 bit shifted by 1.  */
./include/api/elf.h:#define R_390_PLT16DBL          18      /* 16 bit PC rel. PLT shifted by 1.  */
./include/api/elf.h:#define R_390_PC32DBL           19      /* PC relative 32 bit shifted by 1.  */
./include/api/elf.h:#define R_390_PLT32DBL          20      /* 32 bit PC rel. PLT shifted by 1.  */
./include/api/elf.h:#define R_390_GOTPCDBL          21      /* 32 bit PC rel. GOT shifted by 1.  */
./include/api/elf.h:#define R_390_64                22      /* Direct 64 bit.  */
./include/api/elf.h:#define R_390_PC64              23      /* PC relative 64 bit.  */
./include/api/elf.h:#define R_390_GOT64             24      /* 64 bit GOT offset.  */
./include/api/elf.h:#define R_390_PLT64             25      /* 64 bit PC relative PLT address.  */
./include/api/elf.h:#define R_390_GOTENT            26      /* 32 bit PC rel. to GOT entry >> 1. */
./include/api/elf.h:#define R_390_GOTOFF16          27      /* 16 bit offset to GOT. */
./include/api/elf.h:#define R_390_GOTOFF64          28      /* 64 bit offset to GOT. */
./include/api/elf.h:#define R_390_GOTPLT12          29      /* 12 bit offset to jump slot.  */
./include/api/elf.h:#define R_390_GOTPLT16          30      /* 16 bit offset to jump slot.  */
./include/api/elf.h:#define R_390_GOTPLT32          31      /* 32 bit offset to jump slot.  */
./include/api/elf.h:#define R_390_GOTPLT64          32      /* 64 bit offset to jump slot.  */
./include/api/elf.h:#define R_390_GOTPLTENT         33      /* 32 bit rel. offset to jump slot.  */
./include/api/elf.h:#define R_390_PLTOFF16          34      /* 16 bit offset from GOT to PLT. */
./include/api/elf.h:#define R_390_PLTOFF32          35      /* 32 bit offset from GOT to PLT. */
./include/api/elf.h:#define R_390_PLTOFF64          36      /* 16 bit offset from GOT to PLT. */
./include/api/elf.h:#define R_390_TLS_LOAD          37      /* Tag for load insn in TLS code.  */
./include/api/elf.h:#define R_390_TLS_GDCALL        38      /* Tag for function call in general
./include/api/elf.h:#define R_390_TLS_LDCALL        39      /* Tag for function call in local
./include/api/elf.h:#define R_390_TLS_GD32          40      /* Direct 32 bit for general dynamic
./include/api/elf.h:#define R_390_TLS_GD64          41      /* Direct 64 bit for general dynamic
./include/api/elf.h:#define R_390_TLS_GOTIE12       42      /* 12 bit GOT offset for static TLS
./include/api/elf.h:block offset.  */
./include/api/elf.h:#define R_390_TLS_GOTIE32       43      /* 32 bit GOT offset for static TLS
./include/api/elf.h:block offset.  */
./include/api/elf.h:#define R_390_TLS_GOTIE64       44      /* 64 bit GOT offset for static TLS
./include/api/elf.h:block offset. */
./include/api/elf.h:#define R_390_TLS_LDM32         45      /* Direct 32 bit for local dynamic
./include/api/elf.h:#define R_390_TLS_LDM64         46      /* Direct 64 bit for local dynamic
./include/api/elf.h:#define R_390_TLS_IE32          47      /* 32 bit address of GOT entry for
./include/api/elf.h:negated static TLS block offset.  */
./include/api/elf.h:#define R_390_TLS_IE64          48      /* 64 bit address of GOT entry for
./include/api/elf.h:negated static TLS block offset.  */
./include/api/elf.h:#define R_390_TLS_IEENT         49      /* 32 bit rel. offset to GOT entry for
./include/api/elf.h:negated static TLS block offset.  */
./include/api/elf.h:#define R_390_TLS_LE32          50      /* 32 bit negated offset relative to
./include/api/elf.h:#define R_390_TLS_LE64          51      /* 64 bit negated offset relative to
./include/api/elf.h:#define R_390_TLS_LDO32         52      /* 32 bit offset relative to TLS
./include/api/elf.h:#define R_390_TLS_LDO64         53      /* 64 bit offset relative to TLS
./include/api/elf.h:#define R_390_TLS_DTPMOD        54      /* ID of module containing symbol.  */
./include/api/elf.h:#define R_390_TLS_DTPOFF        55      /* Offset in TLS block.  */
./include/api/elf.h:#define R_390_TLS_TPOFF         56      /* Negated offset in static TLS
./include/api/elf.h:#define R_390_20                57      /* Direct 20 bit.  */
./include/api/elf.h:#define R_390_GOT20             58      /* 20 bit GOT offset.  */
./include/api/elf.h:#define R_390_GOTPLT20          59      /* 20 bit offset to jump slot.  */
./include/api/elf.h:#define R_390_TLS_GOTIE20       60      /* 20 bit GOT offset for static TLS
./include/api/elf.h:block offset.  */
./include/api/elf.h:#define R_390_NUM               61
./include/api/elf.h:#define R_CRIS_NONE             0
./include/api/elf.h:#define R_CRIS_8                1
./include/api/elf.h:#define R_CRIS_16               2
./include/api/elf.h:#define R_CRIS_32               3
./include/api/elf.h:#define R_CRIS_8_PCREL          4
./include/api/elf.h:#define R_CRIS_16_PCREL         5
./include/api/elf.h:#define R_CRIS_32_PCREL         6
./include/api/elf.h:#define R_CRIS_GNU_VTINHERIT    7
./include/api/elf.h:#define R_CRIS_GNU_VTENTRY      8
./include/api/elf.h:#define R_CRIS_COPY             9
./include/api/elf.h:#define R_CRIS_GLOB_DAT         10
./include/api/elf.h:#define R_CRIS_JUMP_SLOT        11
./include/api/elf.h:#define R_CRIS_RELATIVE         12
./include/api/elf.h:#define R_CRIS_16_GOT           13
./include/api/elf.h:#define R_CRIS_32_GOT           14
./include/api/elf.h:#define R_CRIS_16_GOTPLT        15
./include/api/elf.h:#define R_CRIS_32_GOTPLT        16
./include/api/elf.h:#define R_CRIS_32_GOTREL        17
./include/api/elf.h:#define R_CRIS_32_PLT_GOTREL    18
./include/api/elf.h:#define R_CRIS_32_PLT_PCREL     19
./include/api/elf.h:#define R_CRIS_NUM              20
./include/api/elf.h:#define R_X86_64_NONE           0       /* No reloc */
./include/api/elf.h:#define R_X86_64_64             1       /* Direct 64 bit  */
./include/api/elf.h:#define R_X86_64_PC32           2       /* PC relative 32 bit signed */
./include/api/elf.h:#define R_X86_64_GOT32          3       /* 32 bit GOT entry */
./include/api/elf.h:#define R_X86_64_PLT32          4       /* 32 bit PLT address */
./include/api/elf.h:#define R_X86_64_COPY           5       /* Copy symbol at runtime */
./include/api/elf.h:#define R_X86_64_GLOB_DAT       6       /* Create GOT entry */
./include/api/elf.h:#define R_X86_64_JUMP_SLOT      7       /* Create PLT entry */
./include/api/elf.h:#define R_X86_64_RELATIVE       8       /* Adjust by program base */
./include/api/elf.h:#define R_X86_64_GOTPCREL       9       /* 32 bit signed PC relative
./include/api/elf.h:offset to GOT */
./include/api/elf.h:#define R_X86_64_32             10      /* Direct 32 bit zero extended */
./include/api/elf.h:#define R_X86_64_32S            11      /* Direct 32 bit sign extended */
./include/api/elf.h:#define R_X86_64_16             12      /* Direct 16 bit zero extended */
./include/api/elf.h:#define R_X86_64_PC16           13      /* 16 bit sign extended pc relative */
./include/api/elf.h:#define R_X86_64_8              14      /* Direct 8 bit sign extended  */
./include/api/elf.h:#define R_X86_64_PC8            15      /* 8 bit sign extended pc relative */
./include/api/elf.h:#define R_X86_64_DTPMOD64       16      /* ID of module containing symbol */
./include/api/elf.h:#define R_X86_64_DTPOFF64       17      /* Offset in module's TLS block */
./include/api/elf.h:#define R_X86_64_TPOFF64        18      /* Offset in initial TLS block */
./include/api/elf.h:#define R_X86_64_TLSGD          19      /* 32 bit signed PC relative offset
./include/api/elf.h:to two GOT entries for GD symbol */
./include/api/elf.h:#define R_X86_64_TLSLD          20      /* 32 bit signed PC relative offset
./include/api/elf.h:to two GOT entries for LD symbol */
./include/api/elf.h:#define R_X86_64_DTPOFF32       21      /* Offset in TLS block */
./include/api/elf.h:#define R_X86_64_GOTTPOFF       22      /* 32 bit signed PC relative offset
./include/api/elf.h:        to GOT entry for IE symbol */
./include/api/elf.h:#define R_X86_64_TPOFF32        23      /* Offset in initial TLS block */
./include/api/elf.h:#define R_X86_64_NUM            24
./include/api/elf.h:#define R_MN10300_NONE          0       /* No reloc.  */
./include/api/elf.h:#define R_MN10300_32            1       /* Direct 32 bit.  */
./include/api/elf.h:#define R_MN10300_16            2       /* Direct 16 bit.  */
./include/api/elf.h:#define R_MN10300_8             3       /* Direct 8 bit.  */
./include/api/elf.h:#define R_MN10300_PCREL32       4       /* PC-relative 32-bit.  */
./include/api/elf.h:#define R_MN10300_PCREL16       5       /* PC-relative 16-bit signed.  */
./include/api/elf.h:#define R_MN10300_PCREL8        6       /* PC-relative 8-bit signed.  */
./include/api/elf.h:#define R_MN10300_GNU_VTINHERIT 7       /* Ancient C++ vtable garbage... */
./include/api/elf.h:#define R_MN10300_GNU_VTENTRY   8       /* ... collection annotation.  */
./include/api/elf.h:#define R_MN10300_24            9       /* Direct 24 bit.  */
./include/api/elf.h:#define R_MN10300_GOTPC32       10      /* 32-bit PCrel offset to GOT.  */
./include/api/elf.h:#define R_MN10300_GOTPC16       11      /* 16-bit PCrel offset to GOT.  */
./include/api/elf.h:#define R_MN10300_GOTOFF32      12      /* 32-bit offset from GOT.  */
./include/api/elf.h:#define R_MN10300_GOTOFF24      13      /* 24-bit offset from GOT.  */
./include/api/elf.h:#define R_MN10300_GOTOFF16      14      /* 16-bit offset from GOT.  */
./include/api/elf.h:#define R_MN10300_PLT32         15      /* 32-bit PCrel to PLT entry.  */
./include/api/elf.h:#define R_MN10300_PLT16         16      /* 16-bit PCrel to PLT entry.  */
./include/api/elf.h:#define R_MN10300_GOT32         17      /* 32-bit offset to GOT entry.  */
./include/api/elf.h:#define R_MN10300_GOT24         18      /* 24-bit offset to GOT entry.  */
./include/api/elf.h:#define R_MN10300_GOT16         19      /* 16-bit offset to GOT entry.  */
./include/api/elf.h:#define R_MN10300_COPY          20      /* Copy symbol at runtime.  */
./include/api/elf.h:#define R_MN10300_GLOB_DAT      21      /* Create GOT entry.  */
./include/api/elf.h:#define R_MN10300_JMP_SLOT      22      /* Create PLT entry.  */
./include/api/elf.h:#define R_MN10300_RELATIVE      23      /* Adjust by program base.  */
./include/api/elf.h:#define R_MN10300_NUM           24
./include/api/elf.h:#define R_M32R_NONE             0       /* No reloc. */
./include/api/elf.h:#define R_M32R_16               1       /* Direct 16 bit. */
./include/api/elf.h:#define R_M32R_32               2       /* Direct 32 bit. */
./include/api/elf.h:#define R_M32R_24               3       /* Direct 24 bit. */
./include/api/elf.h:#define R_M32R_10_PCREL         4       /* PC relative 10 bit shifted. */
./include/api/elf.h:#define R_M32R_18_PCREL         5       /* PC relative 18 bit shifted. */
./include/api/elf.h:#define R_M32R_26_PCREL         6       /* PC relative 26 bit shifted. */
./include/api/elf.h:#define R_M32R_HI16_ULO         7       /* High 16 bit with unsigned low. */
./include/api/elf.h:#define R_M32R_HI16_SLO         8       /* High 16 bit with signed low. */
./include/api/elf.h:#define R_M32R_LO16             9       /* Low 16 bit. */
./include/api/elf.h:#define R_M32R_SDA16            10      /* 16 bit offset in SDA. */
./include/api/elf.h:#define R_M32R_GNU_VTINHERIT    11
./include/api/elf.h:#define R_M32R_GNU_VTENTRY      12
./include/api/elf.h:#define R_M32R_16_RELA          33      /* Direct 16 bit. */
./include/api/elf.h:#define R_M32R_32_RELA          34      /* Direct 32 bit. */
./include/api/elf.h:#define R_M32R_24_RELA          35      /* Direct 24 bit. */
./include/api/elf.h:#define R_M32R_10_PCREL_RELA    36      /* PC relative 10 bit shifted. */
./include/api/elf.h:#define R_M32R_18_PCREL_RELA    37      /* PC relative 18 bit shifted. */
./include/api/elf.h:#define R_M32R_26_PCREL_RELA    38      /* PC relative 26 bit shifted. */
./include/api/elf.h:#define R_M32R_HI16_ULO_RELA    39      /* High 16 bit with unsigned low */
./include/api/elf.h:#define R_M32R_HI16_SLO_RELA    40      /* High 16 bit with signed low */
./include/api/elf.h:#define R_M32R_LO16_RELA        41      /* Low 16 bit */
./include/api/elf.h:#define R_M32R_SDA16_RELA       42      /* 16 bit offset in SDA */
./include/api/elf.h:#define R_M32R_RELA_GNU_VTINHERIT       43
./include/api/elf.h:#define R_M32R_RELA_GNU_VTENTRY 44
./include/api/elf.h:#define R_M32R_GOT24            48      /* 24 bit GOT entry */
./include/api/elf.h:#define R_M32R_26_PLTREL        49      /* 26 bit PC relative to PLT shifted */
./include/api/elf.h:#define R_M32R_COPY             50      /* Copy symbol at runtime */
./include/api/elf.h:#define R_M32R_GLOB_DAT         51      /* Create GOT entry */
./include/api/elf.h:#define R_M32R_JMP_SLOT         52      /* Create PLT entry */
./include/api/elf.h:#define R_M32R_RELATIVE         53      /* Adjust by program base */
./include/api/elf.h:#define R_M32R_GOTOFF           54      /* 24 bit offset to GOT */
./include/api/elf.h:#define R_M32R_GOTPC24          55      /* 24 bit PC relative offset to GOT */
./include/api/elf.h:#define R_M32R_GOT16_HI_ULO     56      /* High 16 bit GOT entry with unsigned
./include/api/elf.h:#define R_M32R_GOT16_HI_SLO     57      /* High 16 bit GOT entry with signed
./include/api/elf.h:#define R_M32R_GOT16_LO         58      /* Low 16 bit GOT entry */
./include/api/elf.h:#define R_M32R_GOTPC_HI_ULO     59      /* High 16 bit PC relative offset to
./include/api/elf.h:#define R_M32R_GOTPC_HI_SLO     60      /* High 16 bit PC relative offset to
./include/api/elf.h:#define R_M32R_GOTPC_LO         61      /* Low 16 bit PC relative offset to
./include/api/elf.h:#define R_M32R_GOTOFF_HI_ULO    62      /* High 16 bit offset to GOT
./include/api/elf.h:#define R_M32R_GOTOFF_HI_SLO    63      /* High 16 bit offset to GOT
./include/api/elf.h:#define R_M32R_GOTOFF_LO        64      /* Low 16 bit offset to GOT */
./include/api/elf.h:#define R_M32R_NUM              256     /* Keep this the last entry. */
./include/api/exec.h:int do_execve(const char *filename, char *const *argv, char *const *envp, struct regs *regs);
./include/api/exec.h:void kernel_execve(const char *filename, char *const *argv, char *const *envp);
./include/api/syscall.h:#ifdef __KERNEL__
./include/api/syscall.h:#endif
./include/api/syscall.h:/* Trap number for syscalls */
./include/api/syscall.h:#define INTR_SYSCALL 0x2e
./include/api/syscall.h:#define SYS_syscall             0
./include/api/syscall.h:#define SYS_exit                1
./include/api/syscall.h:#define SYS_fork                2
./include/api/syscall.h:#define SYS_read                3
./include/api/syscall.h:#define SYS_write               4
./include/api/syscall.h:#define SYS_open                5
./include/api/syscall.h:#define SYS_close               6
./include/api/syscall.h:#define SYS_waitpid             7
./include/api/syscall.h:#define SYS_link                8
./include/api/syscall.h:#define SYS_unlink              9
./include/api/syscall.h:#define SYS_execve              10
./include/api/syscall.h:#define SYS_chdir               11
./include/api/syscall.h:#define SYS_sleep               12 /* NYI */
./include/api/syscall.h:#define SYS_lseek               14
./include/api/syscall.h:#define SYS_sync                15
./include/api/syscall.h:#define SYS_nuke                16 /* NYI */
./include/api/syscall.h:#define SYS_dup                 17
./include/api/syscall.h:#define SYS_pipe                18 /* NYI */
./include/api/syscall.h:#define SYS_ioctl               19 /* NYI */
./include/api/syscall.h:#define SYS_rmdir               21
./include/api/syscall.h:#define SYS_mkdir               22
./include/api/syscall.h:#define SYS_getdents            23
./include/api/syscall.h:#define SYS_mmap                24
./include/api/syscall.h:#define SYS_mprotect            25 /* NYI */
./include/api/syscall.h:#define SYS_munmap              26
./include/api/syscall.h:#define SYS_rename              27 /* NYI */
./include/api/syscall.h:#define SYS_uname               28
./include/api/syscall.h:#define SYS_thr_create          29 /* NYI */
./include/api/syscall.h:#define SYS_thr_cancel          30
./include/api/syscall.h:#define SYS_thr_exit            31
./include/api/syscall.h:#define SYS_thr_yield           32
./include/api/syscall.h:#define SYS_thr_join            33 /* NYI */
./include/api/syscall.h:#define SYS_gettid              34 /* NYI */
./include/api/syscall.h:#define SYS_getpid              35
./include/api/syscall.h:#define SYS_errno               39
./include/api/syscall.h:#define SYS_halt                40
./include/api/syscall.h:#define SYS_get_free_mem        41 /* NYI */
./include/api/syscall.h:#define SYS_set_errno           42
./include/api/syscall.h:#define SYS_dup2                43
./include/api/syscall.h:#define SYS_brk                 44
./include/api/syscall.h:#define SYS_mount               45
./include/api/syscall.h:#define SYS_umount              46
./include/api/syscall.h:#define SYS_stat                47
./include/api/syscall.h:#define SYS_debug               9001
./include/api/syscall.h:#define SYS_kshell              9002
./include/api/syscall.h:typedef struct argstr {
./include/api/syscall.h:typedef struct argvec {
./include/api/syscall.h:typedef struct waitpid_args {
./include/api/syscall.h:typedef struct mmap_args {
./include/api/syscall.h:        int     mma_flags;
./include/api/syscall.h:        int     mma_fd;
./include/api/syscall.h:        off_t   mma_off;
./include/api/syscall.h:typedef struct munmap_args {
./include/api/syscall.h:typedef struct open_args {
./include/api/syscall.h:        argstr_t filename;
./include/api/syscall.h:        int      flags;
./include/api/syscall.h:typedef struct read_args {
./include/api/syscall.h:        int     fd;
./include/api/syscall.h:        void   *buf;
./include/api/syscall.h:typedef struct write_args {
./include/api/syscall.h:        int     fd;
./include/api/syscall.h:        void   *buf;
./include/api/syscall.h:typedef struct mkdir_args {
./include/api/syscall.h:typedef struct link_args {
./include/api/syscall.h:        argstr_t from;
./include/api/syscall.h:typedef struct execve_args {
./include/api/syscall.h:        argstr_t filename;
./include/api/syscall.h:typedef struct rename_args {
./include/api/syscall.h:typedef struct getdents_args {
./include/api/syscall.h:        int            fd;
./include/api/syscall.h:typedef struct lseek_args {
./include/api/syscall.h:        int fd;
./include/api/syscall.h:        int offset;
./include/api/syscall.h:typedef struct dup2_args {
./include/api/syscall.h:        int ofd;
./include/api/syscall.h:        int nfd;
./include/api/syscall.h:#ifdef __MOUNTING__
./include/api/syscall.h:typedef struct mount_args {
./include/api/syscall.h:        argstr_t fstype;
./include/api/syscall.h:#endif
./include/api/syscall.h:typedef struct stat_args {
./include/api/syscall.h:        struct stat *buf;
./include/api/utsname.h:#define _UTSNAME_LENGTH 128
./include/api/utsname.h:int uname(struct utsname *buf);
./include/boot/config.h:#define KERNEL_PHYS_BASE 0x100000
./include/boot/config.h:#define MEMORY_MAP_BASE 0x9000
./include/drivers/blockdev.h:#define BLOCK_SIZE PAGE_SIZE
./include/drivers/blockdev.h:typedef struct blockdev {
./include/drivers/blockdev.h:        /* Link on the list of block-oriented devices */
./include/drivers/blockdev.h:typedef struct blockdev_ops {
./include/drivers/blockdev.h:         * Reads a block from the block device. This call will block.
./include/drivers/blockdev.h:         * @param buf the memory into which to read the block (must be
./include/drivers/blockdev.h:         * @param loc the number of the block to start reading from
./include/drivers/blockdev.h:         * @param count the number of blocks to read
./include/drivers/blockdev.h:         * @return 0 on success, -errno on failure
./include/drivers/blockdev.h:        int (*read_block)(blockdev_t *bdev, char *buf,
./include/drivers/blockdev.h:         * @param buf the memory from which to write the block (must be
./include/drivers/blockdev.h:         * @param loc the number of the block to start writing at
./include/drivers/blockdev.h:         * @param count the number of blocks to write
./include/drivers/blockdev.h:         * @return 0 on success, -errno on failure
./include/drivers/blockdev.h:        int (*write_block)(blockdev_t *bdev, const char *buf,
./include/drivers/blockdev.h: * @param id the device id of the block device to find
./include/drivers/blockdev.h: * @return the block device with the given id if it exists, or NULL if
./include/drivers/blockdev.h: * it cannot be found
./include/drivers/blockdev.h: * Cleans and frees all resident pages belonging to a given block
./include/drivers/blockdev.h: * @param dev the block device to flush
./include/drivers/blockdev.h:void blockdev_flush_all(blockdev_t *dev);
./include/drivers/bytedev.h:struct pframe;
./include/drivers/bytedev.h:typedef struct bytedev {
./include/drivers/bytedev.h:typedef struct bytedev_ops {
./include/drivers/bytedev.h:        int (*read)(bytedev_t *dev, int offset, void *buf, int count);
./include/drivers/bytedev.h:        int (*write)(bytedev_t *dev, int offset, const void *buf, int count);
./include/drivers/bytedev.h:        int (*mmap)(struct vnode *file, struct vmarea *vma, struct mmobj **ret);
./include/drivers/bytedev.h:        int (*fillpage)(struct vnode *file, off_t offset, void *pagebuf);
./include/drivers/bytedev.h:        int (*dirtypage)(struct vnode *file, off_t offset);
./include/drivers/bytedev.h:        int (*cleanpage)(struct vnode *file, off_t offset, void *pagebuf);
./include/drivers/bytedev.h: * @param id the device id of the byte device to find
./include/drivers/bytedev.h: * @return the byte device with the given id if it exists, or NULL if
./include/drivers/bytedev.h: * it cannot be found
./include/drivers/dev.h: * A Weenix "device identifier" is the concatenation of:
./include/drivers/dev.h: * The device identifiers for block devices and character devices are
./include/drivers/dev.h: * with major 3, minor 5 (for example). They would be distinct.
./include/drivers/dev.h: * Weenix's device number allocation/assignment scheme is as follows:
./include/drivers/dev.h: *     - major 0 (byte or block), minor 0: reserved as an analogue of NULL
./include/drivers/dev.h: *       for device id's
./include/drivers/dev.h: *         - minor 0:          first disk device
./include/drivers/dev.h:#define MINOR_BITS              8
./include/drivers/dev.h:#define MINOR_MASK              ((1U << MINOR_BITS) - 1)
./include/drivers/dev.h:#define MAJOR(devid)            ((unsigned) ((devid) >> MINOR_BITS))
./include/drivers/dev.h:#define MINOR(devid)            ((unsigned) ((devid) & MINOR_MASK))
./include/drivers/dev.h:#define MKDEVID(major, minor)   (((major) << MINOR_BITS) | (minor))
./include/drivers/dev.h:/* convenience definition: the NULL device id: */
./include/drivers/dev.h:#define NULL_DEVID              (MKDEVID(0, 0))
./include/drivers/dev.h:#define MEM_NULL_DEVID          (MKDEVID(1, 0))
./include/drivers/dev.h:#define MEM_ZERO_DEVID          (MKDEVID(1, 1))
./include/drivers/dev.h:#define DISK_MAJOR 1
./include/drivers/dev.h:#define MEM_MAJOR       1
./include/drivers/dev.h:#define MEM_NULL_MINOR  0
./include/drivers/dev.h:#define MEM_ZERO_MINOR  1
./include/fs/dirent.h:/*  dirent.h - filesystem-independent directory entry
./include/fs/dirent.h:#ifdef __KERNEL__
./include/fs/dirent.h:#include "config.h"
./include/fs/dirent.h:#include "weenix/config.h"
./include/fs/dirent.h:#endif
./include/fs/dirent.h:typedef struct dirent {
./include/fs/dirent.h:        off_t   d_off;                  /* seek pointer of next entry */
./include/fs/dirent.h:        char    d_name[NAME_LEN + 1];   /* filename */
./include/fs/dirent.h:#define d_fileno d_ino
./include/fs/fcntl.h:/* fcntl.h - File access bits
./include/fs/fcntl.h:/* File access modes for open(). */
./include/fs/fcntl.h:#define O_RDONLY        0
./include/fs/fcntl.h:#define O_WRONLY        1
./include/fs/fcntl.h:#define O_RDWR          2
./include/fs/fcntl.h:/* File status flags for open(). */
./include/fs/fcntl.h:#define O_CREAT         0x100   /* Create file if non-existent. */
./include/fs/fcntl.h:#define O_TRUNC         0x200   /* Truncate to zero length. */
./include/fs/fcntl.h:#define O_APPEND        0x400   /* Append to file. */
./include/fs/file.h:#define FMODE_READ    1
./include/fs/file.h:#define FMODE_WRITE   2
./include/fs/file.h:#define FMODE_APPEND  4
./include/fs/file.h:typedef struct file {
./include/fs/file.h:         * The current position in the file. Can be modified by system calls
./include/fs/file.h:         * described in the man pages of those calls.
./include/fs/file.h:        off_t                   f_pos;
./include/fs/file.h:         * The mode in which this file was opened. This is a mask of the flags
./include/fs/file.h:         * FMODE_READ, FMODE_WRITE, and FMODE_APPEND. It is set when the file
./include/fs/file.h:         * is first opened, and use to restrict the operations that can be
./include/fs/file.h:         * performed on the underlying vnode.
./include/fs/file.h:        int                     f_mode;
./include/fs/file.h:         * The number of references to this struct. This is nearly the same as
./include/fs/file.h:         * the vnode's vn_refcount member.
./include/fs/file.h:        int                     f_refcount;
./include/fs/file.h:         * The vnode which corresponds to this file.
./include/fs/file.h:        struct vnode            *f_vnode;
./include/fs/file.h:} file_t;
./include/fs/file.h: * Returns the file_t assiciated with the given file descriptor for the
./include/fs/file.h: * current process. If there is no associated file_t, returns NULL.
./include/fs/file.h: * If the passed fd == -1, a new file_t, not associated with any process
./include/fs/file.h: * or file descriptor, is created and returned with its refcount set to
./include/fs/file.h:struct file *fget(int fd);
./include/fs/file.h: * fref() increments the reference count on the given file.
./include/fs/file.h:void fref(file_t *f);
./include/fs/file.h: * fput() decrements the reference count on the given file.
./include/fs/file.h: * If the refcount reaches 0, the storage for the given file_t will be
./include/fs/file.h: * released (f won't point to a valid memory address anymore), and the
./include/fs/file.h: * refcount on the associated vnode (if any) will be decremented.
./include/fs/file.h:void fput(file_t *f);
./include/fs/lseek.h:#define SEEK_SET        0
./include/fs/lseek.h:#define SEEK_CUR        1
./include/fs/lseek.h:#define SEEK_END        2
./include/fs/open.h:int do_open(const char *filename, int flags);
./include/fs/open.h:int get_empty_fd(struct proc *p);
./include/fs/stat.h:#define S_IFCHR         0x0100  /* character special */
./include/fs/stat.h:#define S_IFDIR         0x0200 /* directory */
./include/fs/stat.h:#define S_IFBLK         0x0400 /* block special */
./include/fs/stat.h:#define S_IFREG         0x0800 /* regular */
./include/fs/stat.h:#define S_IFLNK         0x1000 /* symlink */
./include/fs/stat.h:#define _S_TYPE(m)      ((m) & 0xFF00)
./include/fs/stat.h:#define S_ISCHR(m)      (_S_TYPE(m) == S_IFCHR)
./include/fs/stat.h:#define S_ISDIR(m)      (_S_TYPE(m) == S_IFDIR)
./include/fs/stat.h:#define S_ISBLK(m)      (_S_TYPE(m) == S_IFBLK)
./include/fs/stat.h:#define S_ISREG(m)      (_S_TYPE(m) == S_IFREG)
./include/fs/stat.h:#define S_ISLNK(m)      (_S_TYPE(m) == S_IFLNK)
./include/fs/vfs.h:#include "fs/open.h"
./include/fs/vfs.h:struct file;
./include/fs/vfs.h:struct vfs;
./include/fs/vfs.h:struct fs;
./include/fs/vfs.h:/* name_match: fname should be null-terminated, name is namelen long */
./include/fs/vfs.h:#define name_match(fname, name, namelen) \
./include/fs/vfs.h:        ( strlen(fname) == namelen && !strncmp((fname), (name), (namelen)) )
./include/fs/vfs.h:typedef struct fs_ops {
./include/fs/vfs.h:         * read_vnode will be passed a vnode_t*, which will have its vn_fs
./include/fs/vfs.h:         * and vn_vno fields initialized.
./include/fs/vfs.h:         * read_vnode must initialize the following members of the provided
./include/fs/vfs.h:         *         and vn_devid if appropriate
./include/fs/vfs.h:         * The inverse of read_vnode; delete_vnode is called by vput when the
./include/fs/vfs.h:         * specified vnode_t no longer needs to exist (it is neither actively
./include/fs/vfs.h:         * nor passively referenced).
./include/fs/vfs.h:         * Returns 1 if the vnode still exists in the filesystem, 0 of it can
./include/fs/vfs.h:         * be deleted. Called by vput when there are no active references to
./include/fs/vfs.h:         * the vnode. If query_vnode returns 0, vput evicts all pages of the vnode
./include/fs/vfs.h:         * from memory so that it can be deleted.
./include/fs/vfs.h:         * Unmount the filesystem, performing any necessary reference count
./include/fs/vfs.h:         * checks.  Returns 0 on success, negative number on error.  If this
./include/fs/vfs.h:         * is NULL, the default action (vput(fs->fs_root)) is performed.
./include/fs/vfs.h:        int (*umount)(struct fs *fs);
./include/fs/vfs.h:} fs_ops_t;
./include/fs/vfs.h:#ifndef STR_MAX
./include/fs/vfs.h:#define STR_MAX 32
./include/fs/vfs.h:#endif
./include/fs/vfs.h:typedef struct fs {
./include/fs/vfs.h:         * The string name of the device from which this file system should
./include/fs/vfs.h:         * be mounted. This may be used by the mount function of some file
./include/fs/vfs.h:        char            fs_dev[STR_MAX];
./include/fs/vfs.h:         * The type of file system this structure represents (given as a
./include/fs/vfs.h:         * well-defined string). This is used by the generic VFS mount
./include/fs/vfs.h:         * function to decide which filesystem-specific mount function to
./include/fs/vfs.h:         * call.  Valid values are hard-coded in vfs.c.
./include/fs/vfs.h:        char            fs_type[STR_MAX];
./include/fs/vfs.h:#ifdef __MOUNTING__
./include/fs/vfs.h:         * If mounting is implemented then this should point to the vnode
./include/fs/vfs.h:         * of the file that this file system is mounted on. For the root file
./include/fs/vfs.h:         * system this will just point to the root of that file system.
./include/fs/vfs.h:        struct vnode    *fs_mtpt;
./include/fs/vfs.h:         * An identifier for the mounted file system. This should be enlisted
./include/fs/vfs.h:         * by the the kernel to keep track of all mounted file systems.
./include/fs/vfs.h:        list_link_t     fs_link;
./include/fs/vfs.h:#endif
./include/fs/vfs.h:         * The following members are initialized by the filesystem
./include/fs/vfs.h:         * The struct of operations that define which filesystem-specific
./include/fs/vfs.h:         * functions to call to perform filesystem manipulation.
./include/fs/vfs.h:        fs_ops_t        *fs_op;
./include/fs/vfs.h:         * The root vnode for this filesystem (not to be confused with
./include/fs/vfs.h:         * either / (the root of VFS) or the vnode where the filesystem is
./include/fs/vfs.h:         * mounted, which is on a different file system.
./include/fs/vfs.h:        struct vnode    *fs_root;
./include/fs/vfs.h:        /* Filesystem-specific data. */
./include/fs/vfs.h:        void            *fs_i;
./include/fs/vfs.h:} fs_t;
./include/fs/vfs.h:/* - this is the vnode on which we will mount the vfsroot fs.
./include/fs/vfs.h:extern struct vnode *vfs_root_vn;
./include/fs/vfs.h: * unmount the root filesystem (and first unmount any filesystems mounted
./include/fs/vfs.h: * on the root filesystem in the proper order (bottom up)).
./include/fs/vfs.h:int vfs_shutdown();
./include/fs/vfs.h:/* (the corresponding definitions live in namev.c) */
./include/fs/vfs.h:int open_namev(const char *pathname, int flag,
./include/fs/vfs.h:#ifdef __GETCWD__
./include/fs/vfs.h:int lookup_name(struct vnode *dir, struct vnode *entry, char *buf, size_t size);
./include/fs/vfs.h:int lookup_dirpath(struct vnode *dir, char *buf, size_t size);
./include/fs/vfs.h:#endif /* __GETCWD__ */
./include/fs/vfs.h:int mountfunc(fs_t *fs);
./include/fs/vfs.h:#ifdef __MOUNTING__
./include/fs/vfs.h:int vfs_mount(struct vnode *mtpt, fs_t *fs);
./include/fs/vfs.h:int vfs_umount(fs_t *fs);
./include/fs/vfs.h:#endif
./include/fs/vfs_privtest.h:void vfs_privtest(void);
./include/fs/vfs_syscall.h:#include "fs/open.h"
./include/fs/vfs_syscall.h:#include "fs/stat.h"
./include/fs/vfs_syscall.h:int do_close(int fd);
./include/fs/vfs_syscall.h:int do_read(int fd, void *buf, size_t nbytes);
./include/fs/vfs_syscall.h:int do_write(int fd, const void *buf, size_t nbytes);
./include/fs/vfs_syscall.h:int do_dup(int fd);
./include/fs/vfs_syscall.h:int do_dup2(int ofd, int nfd);
./include/fs/vfs_syscall.h:int do_link(const char *from, const char *to);
./include/fs/vfs_syscall.h:int do_getdent(int fd, struct dirent *dirp);
./include/fs/vfs_syscall.h:int do_lseek(int fd, int offset, int whence);
./include/fs/vfs_syscall.h:int do_stat(const char *path, struct stat *uf);
./include/fs/vfs_syscall.h:#ifdef __MOUNTING__
./include/fs/vfs_syscall.h:/* for mounting implementations only, not required */
./include/fs/vfs_syscall.h:#endif
./include/fs/vnode.h:#include "mm/pframe.h"
./include/fs/vnode.h:struct fs;
./include/fs/vnode.h:typedef struct vnode_ops {
./include/fs/vnode.h:        /* The following functions map directly to their corresponding
./include/fs/vnode.h:         * success, and -errno on failure.
./include/fs/vnode.h:        /* Operations that can be performed on non-directory files: */
./include/fs/vnode.h:         * read transfers at most count bytes from file into buf. It
./include/fs/vnode.h:         * begins reading from the file at offset bytes into the file. On
./include/fs/vnode.h:         * success, it returns the number of bytes transferred, or 0 if the
./include/fs/vnode.h:         * end of the file has been reached (offset >= file->vn_len).
./include/fs/vnode.h:        int (*read)(struct vnode *file, off_t offset, void *buf, size_t count);
./include/fs/vnode.h:         * write transfers count bytes from buf into file. It begins
./include/fs/vnode.h:         * writing at offset bytes into the file. If offset+len extends
./include/fs/vnode.h:         * past the end of the file, the file's length will be increased.
./include/fs/vnode.h:         * If offset is before the end of the file, the existing data is
./include/fs/vnode.h:         * overwritten. On success, it returns the number of bytes
./include/fs/vnode.h:         * transferred.
./include/fs/vnode.h:        int (*write)(struct vnode *file, off_t offset, const void *buf, size_t count);
./include/fs/vnode.h:         * a list of vm_areas) will have been initialized before this
./include/fs/vnode.h:         * argument (not by setting vma->vm_obj). If for any reason
./include/fs/vnode.h:         * returned instead. This function may not perform any operations
./include/fs/vnode.h:         * which must be undone later (the caller is responsible for ref-ing
./include/fs/vnode.h:         * the returned object if necessary), nor may it block.
./include/fs/vnode.h:        int (*mmap)(struct vnode *file, struct vmarea *vma, struct mmobj **ret);
./include/fs/vnode.h:        /* Operations that can be performed on directory files: */
./include/fs/vnode.h:         * and create an entry for this vnode in 'dir' of the specified name.
./include/fs/vnode.h:         * mknod creates a special file for the device specified by
./include/fs/vnode.h:         * 'devid' and an entry for it in 'dir' of the specified name.
./include/fs/vnode.h:         * lookup sets *result to the vnode in dir with the specified name.
./include/fs/vnode.h:         * specified name.
./include/fs/vnode.h:         * unlink removes the link to the vnode in dir specified by name
./include/fs/vnode.h:         * rmdir removes the directory called name from dir. the directory
./include/fs/vnode.h:         * to be removed must be empty (except for . and .. of course).
./include/fs/vnode.h:         * readdir reads one directory entry from the dir into the struct
./include/fs/vnode.h:         * dirent. On success, it returns the amount that offset should be
./include/fs/vnode.h:         * subsequent call to readdir. If the end of the file as been
./include/fs/vnode.h:         * reached (offset == file->vn_len), no directory entry will be
./include/fs/vnode.h:        int (*readdir)(struct vnode *dir, off_t offset, struct dirent *d);
./include/fs/vnode.h:        /* Operations that can be performed on any type of file: */
./include/fs/vnode.h:         * stat sets the fields in the given buf, filling it with
./include/fs/vnode.h:         * information about file.
./include/fs/vnode.h:        int (*stat)(struct vnode *vnode, struct stat *buf);
./include/fs/vnode.h:         * Read the page of 'vnode' containing 'offset' into the
./include/fs/vnode.h:         * page-aligned and page-sized buffer pointed to by
./include/fs/vnode.h:         * 'pagebuf'.
./include/fs/vnode.h:        int (*fillpage)(struct vnode *vnode, off_t offset, void *pagebuf);
./include/fs/vnode.h:         * belonging to 'vnode' that contains 'offset'. (If the
./include/fs/vnode.h:         * underlying fs supports sparse blocks/pages, and the page
./include/fs/vnode.h:         * containing this offset is currently sparse, this is
./include/fs/vnode.h:         * the underlying fs for that block/page). Return zero on
./include/fs/vnode.h:         * success and nonzero otherwise (i.e., if there are no
./include/fs/vnode.h:         * free blocks in the underlying fs, etc).
./include/fs/vnode.h:        int (*dirtypage)(struct vnode *vnode, off_t offset);
./include/fs/vnode.h:         * Write the contents of the page-aligned and page-sized
./include/fs/vnode.h:         * buffer pointed to by 'pagebuf' to the page of 'vnode'
./include/fs/vnode.h:         * containing 'offset'.
./include/fs/vnode.h:        int (*cleanpage)(struct vnode *vnode, off_t offset, void *pagebuf);
./include/fs/vnode.h:#define VN_BUSY        0x1
./include/fs/vnode.h:typedef struct vnode {
./include/fs/vnode.h:         * Function pointers to the implementations of file operations (the
./include/fs/vnode.h:         * functions are provided by the filesystem implementation).
./include/fs/vnode.h:         * The filesystem to which this vnode belongs. This is initialized by
./include/fs/vnode.h:         * the VFS subsystem when the vnode is first created and should never
./include/fs/vnode.h:        struct fs          *vn_fs;
./include/fs/vnode.h:#ifdef __MOUNTING__
./include/fs/vnode.h:        /* This field is used only for implementing mount points (not required) */
./include/fs/vnode.h:        /* This field points the the root of the file system mounted at
./include/fs/vnode.h:         * this vnode. If no file system is mounted at this point this is a
./include/fs/vnode.h:         * self pointer (i.e. vn->vn_mount = vn). See vget for why this is
./include/fs/vnode.h:         * makes things easier for us. */
./include/fs/vnode.h:#endif
./include/fs/vnode.h:        /* XXX: changed because of big changes in vm_obj subsystem.
./include/fs/vnode.h:         * The object responsible for managing the memory where pages read
./include/fs/vnode.h:         * from this file reside. The VFS subsystem may use this field, but it
./include/fs/vnode.h:         * The number of references to this vnode. Note that the VFS subsystem
./include/fs/vnode.h:         * should only read this value, not modify it.
./include/fs/vnode.h:#define                    vn_refcount     vn_mmobj.mmo_refcount
./include/fs/vnode.h:         * The number of memory pages belonging to this file which are currently
./include/fs/vnode.h:         * not modify it.
./include/fs/vnode.h:#define                    vn_nrespages    vn_mmobj.mmo_nrespages
./include/fs/vnode.h:         * A number which uniquely identifies this vnode within its filesystem.
./include/fs/vnode.h:         * of a file).
./include/fs/vnode.h:         * Length of file.  Initialized at the fs-implementation-level (in the
./include/fs/vnode.h:         * 'read_vnode' fs_t entry point).  Maintained at the filesystem
./include/fs/vnode.h:         * implementation level (within the implementations of relevant vnode
./include/fs/vnode.h:        off_t              vn_len;
./include/fs/vnode.h:         * the underlying filesystem implementation.
./include/fs/vnode.h:         * A generic pointer which the file system can use to store any extra
./include/fs/vnode.h:        /* XXX: also changed because of name changes to bytedev_t and blockdev_t */
./include/fs/vnode.h:         * The device identifier.
./include/fs/vnode.h:         * Only relevant to vnodes representing device files.
./include/fs/vnode.h:         * A reference to the character device.
./include/fs/vnode.h:         * Only relevant to vnodes representing character device files.
./include/fs/vnode.h:         * A reference to the block device.
./include/fs/vnode.h:         * Only relevant to vnodes representing block device files.
./include/fs/vnode.h:        /* Used (only) by the v{get,ref,put} facilities (vfs/vnode.c): */
./include/fs/vnode.h:        int                vn_flags;       /* VN_BUSY */
./include/fs/vnode.h:        ktqueue_t          vn_waitq;       /* queue of threads waiting for vnode
./include/fs/vnode.h: *         The following members of struct vnode play a primary role in
./include/fs/vnode.h: *             - vn_refcount
./include/fs/vnode.h: *                 - This integer counts every memory reference to the
./include/fs/vnode.h: *                   number of (vnode_t *)'s that have the address of this
./include/fs/vnode.h: *                   particular vnode_t as their value. The value of
./include/fs/vnode.h: *                   vn_refcount is, by convention, controlled via
./include/fs/vnode.h: *                   'vget(...)', 'vref(...)', and 'vput(...)'.
./include/fs/vnode.h: *                   represented by a vm_page structure (see vm_page.h for
./include/fs/vnode.h: *                   the definition of this structure). Each such vm_page
./include/fs/vnode.h: *                   within the relevant vnode and, as a result of this,
./include/fs/vnode.h: *                   vn_refcount is >= vn_nrespages.
./include/fs/vnode.h: *         Life cycle of a vnode:
./include/fs/vnode.h: *             - A vnode either doesn't exist or is in one of two states
./include/fs/vnode.h: *               that we define as follows:
./include/fs/vnode.h: *                 - (1) actively-referenced: (vn_refcount > vn_nrespages > 0)
./include/fs/vnode.h: *                 - (2) passively-referenced: (vn_refcount == vn_nrespages > 0)
./include/fs/vnode.h: *     Obtain a vnode representing the file that filesystem 'fs' identifies
./include/fs/vnode.h: *     given filesystem and vnode number.  If a vnode for the given file
./include/fs/vnode.h: *     the reference count of that vnode is incremented and it is returned.
./include/fs/vnode.h: *     reference count of 1.
./include/fs/vnode.h: *     This function has no unsuccessful return.
./include/fs/vnode.h:struct vnode *vget(struct fs *fs, ino_t vnum);
./include/fs/vnode.h: *     Increment the reference count of the provided vnode.
./include/fs/vnode.h:void vref(vnode_t *vn);
./include/fs/vnode.h: *     This function decrements the reference count on this vnode.
./include/fs/vnode.h: *     If, as a result of this, vn_refcount reaches zero, the underlying
./include/fs/vnode.h: *     fs's 'delete_vnode' entry point will be called and the vnode will be
./include/fs/vnode.h: *     freed.
./include/fs/vnode.h: *     If, as a result of this, vn_refcount reaches vn_respages and
./include/fs/vnode.h: *     vn_nrespages is > 0 (meaning only passive references exist) and
./include/fs/vnode.h: *     the linkcount on the filesystem is zero (determined using query_vnode),
./include/fs/vnode.h: *     all resident pages will be forcibly uncached, the underlying fs's
./include/fs/vnode.h: *     'delete_vnode' entry point will be called, and the vnode will be freed.
./include/fs/vnode.h: *     If the vnode is freed, vn will not point to a valid memory address
./include/fs/vnode.h:/*     Unmounting (shutting down the VFS) is the primary reason for the
./include/fs/vnode.h: *     existence of the following three routines (when unmounting an s5 fs,
./include/fs/vnode.h: *         Checks to see if there are any actively-referenced vnodes
./include/fs/vnode.h: *         belonging to the specified filesystem.
./include/fs/vnode.h: *         Returns -EBUSY if there is at least one such actively-referenced
./include/fs/vnode.h: *         (Note: only actively-referenced vnodes affect the routine's
./include/fs/vnode.h: *         outcome; (passively-referenced vnodes belonging to 'fs' do
./include/fs/vnode.h:int vfs_is_in_use(struct fs *fs);
./include/fs/vnode.h: *         Clean and uncache all resident pages of all vnodes belonging to
./include/fs/vnode.h: *         the specified fs.
./include/fs/vnode.h:void vnode_flush_all(struct fs *fs);
./include/fs/vnode.h: *         Returns the number of vnodes from this filesystem that are in
./include/fs/vnode.h:int vnode_inuse(struct fs *fs);
./include/fs/vnode.h: *     Prints the vnodes that are in use.  Specifying a fs_t will restrict
./include/fs/vnode.h: *     the vnodes to just that fs.  Specifying NULL will print all vnodes
./include/fs/vnode.h:void vnode_print(struct fs *fs);
./include/main/apic.h:/* Initializes the APIC using data from the ACPI tables.
./include/main/apic.h: * ACPI handlers must be initialized before calling this
./include/main/apic.h: * function. */
./include/main/apic.h:/* Initializes the APIC timer to count down from 'count' and
./include/main/apic.h: * trigger interrupt 'intr' when completed. Counter is (effectively)
./include/main/apic.h: * decremented by 1/'div' every bus clock tick. If 'periodic' is set
./include/main/apic.h: * repeat periodically, otherwise just do it once. This function
./include/main/apic.h: * Returns 0 on success, nonzero on failure.
./include/main/apic.h: * Note that 'div' must be a power of 2 less than 2^8. */
./include/main/apic.h:/* Get the current value of the timer. */
./include/main/apic.h:/* Set the current value of the timer. */
./include/main/apic.h:/* Sets the interrupt priority level. This function should
./include/main/apic.h:/* Gets the interrupt priority level. This function should
./include/main/apic.h:/* Writes to the APIC's memory mapped end-of-interrupt
./include/main/apic.h: * register to indicate that the handling of an interrupt
./include/main/apic.h: * originating from the APIC has been finished. This function
./include/main/apic.h: * should only be called from the interrupt subsystem. */
./include/main/cpuid.h:#define CPUID_VENDOR_AMD          "AuthenticAMD"
./include/main/cpuid.h:#define CPUID_VENDOR_INTEL        "GenuineIntel"
./include/main/cpuid.h:#define CPUID_VENDOR_VIA          "CentaurHauls"
./include/main/cpuid.h:#define CPUID_VENDOR_OLDTRANSMETA "TransmetaCPU"
./include/main/cpuid.h:#define CPUID_VENDOR_TRANSMETA    "GenuineTMx86"
./include/main/cpuid.h:#define CPUID_VENDOR_CYRIX        "CyrixInstead"
./include/main/cpuid.h:#define CPUID_VENDOR_CENTAUR      "CentaurHauls"
./include/main/cpuid.h:#define CPUID_VENDOR_NEXGEN       "NexGenDriven"
./include/main/cpuid.h:#define CPUID_VENDOR_UMC          "UMC UMC UMC "
./include/main/cpuid.h:#define CPUID_VENDOR_SIS          "SiS SiS SiS "
./include/main/cpuid.h:#define CPUID_VENDOR_NSC          "Geode by NSC"
./include/main/cpuid.h:#define CPUID_VENDOR_RISE         "RiseRiseRise"
./include/main/gdt.h:#define GDT_COUNT 16
./include/main/gdt.h:#define GDT_ZERO        0x00
./include/main/gdt.h:#define GDT_KERNEL_TEXT 0x08
./include/main/gdt.h:#define GDT_KERNEL_DATA 0x10
./include/main/gdt.h:#define GDT_USER_TEXT   0x18
./include/main/gdt.h:#define GDT_USER_DATA   0x20
./include/main/gdt.h:#define GDT_TSS         0x28
./include/main/interrupt.h:#define INTR_DIVIDE_BY_ZERO 0x00
./include/main/interrupt.h:#define INTR_INVALID_OPCODE 0x06
./include/main/interrupt.h:#define INTR_GPF 0x0d
./include/main/interrupt.h:#define INTR_PAGE_FAULT 0x0e
./include/main/interrupt.h:#define INTR_PIT 0xf1
./include/main/interrupt.h:#define INTR_APICTIMER 0xf0
./include/main/interrupt.h:#define INTR_KEYBOARD 0xe0
./include/main/interrupt.h:#define INTR_DISK_PRIMARY 0xd0
./include/main/interrupt.h:#define INTR_DISK_SECONDARY 0xd1
./include/main/interrupt.h:/* NOTE: INTR_SYSCALL is not defined here, but is in syscall.h (it must be
./include/main/interrupt.h:#define IPL_LOW 0
./include/main/interrupt.h:#define IPL_HIGH (0xff)
./include/main/interrupt.h:typedef struct regs {
./include/main/interrupt.h:        uint32_t r_eip, r_cs, r_eflags, r_useresp, r_ss; /* pushed by the processor automatically */
./include/main/interrupt.h:/* The function pointer which should be implemented by functions
./include/main/interrupt.h: * with the interrupt subsystem via the intr_register function.
./include/main/interrupt.h: * The regs structure contains the state of the registers saved when
./include/main/interrupt.h:typedef void (*intr_handler_t)(regs_t *regs);
./include/main/interrupt.h:/* Registers an interrupt handler for the given interrupt handler.
./include/main/interrupt.h: * If another handler had been previously registered for this interrupt
./include/main/interrupt.h: * number it is returned, otherwise this function returns NULL. It
./include/main/interrupt.h: * is good practice to assert that this function returns NULL unless
./include/main/interrupt.h: * state, this function returns once an interrupt
./include/main/interrupt.h:         * interrupts are not checked for until the next
./include/main/interrupt.h:         * instruction is executed, this means that the following
./include/main/interrupt.h:         * and does not wake us up from the hlt. */
./include/main/interrupt.h:/* Sets the interrupt priority level for hardware interrupts.
./include/main/interrupt.h: * IPLs and save them for use with this function. IPL_LOW allows
./include/mm/kmalloc.h:void  kfree(void *addr);
./include/mm/mm.h:#define MM_POISON             1
./include/mm/mm.h:#define MM_POISON_ALLOC       0xBB
./include/mm/mm.h:#define MM_POISON_FREE        0xDD
./include/mm/mm.h:#define USER_MEM_LOW          0x00400000 /* inclusive */
./include/mm/mm.h:#define USER_MEM_HIGH         0xc0000000 /* exclusive */
./include/mm/mm.h:#define PTR_SIZE (sizeof(void *))
./include/mm/mm.h:#define PTR_MASK (PTR_SIZE - 1)
./include/mm/mm.h:/* Performs all initialization necessary for the
./include/mm/mm.h: * only once at boot time before any other functions
./include/mm/mm.h:/* This is the first step of initializing the page table system. It
./include/mm/mm.h: * the page directory and first 2 page tables of the permenant page
./include/mm/mm.h: * table mappings for the kernel. One page table identity maps the
./include/mm/mm.h: * first 1mb of physical memory. The other maps the 4mb of physical
./include/mm/mm.h:/* Called from the bootstrap context in order to set up the template
./include/mm/mm.h: * page directory used by all future threads. This cannot be set up
./include/mm/mm.h: * prior to this because the stack is mapped in to the first 4mb
./include/mm/mm.h: * of memory. Page faults are not handled until this function is
./include/mm/mm.h: * only after the page subsystem has been initialized. Slab allocators
./include/mm/mm.h: * and kmalloc will not work until this funciton has been called. */
./include/mm/mman.h:/* Page protection flags.
./include/mm/mman.h:#define PROT_NONE       0x0     /* No access. */
./include/mm/mman.h:#define PROT_READ       0x1     /* Pages can be read. */
./include/mm/mman.h:#define PROT_WRITE      0x2     /* Pages can be written. */
./include/mm/mman.h:#define PROT_EXEC       0x4     /* Pages can be executed. */
./include/mm/mman.h:/* Return value for mmap() on failure.
./include/mm/mman.h:#define MAP_FAILED      ((void*)-1)
./include/mm/mman.h:#define MAP_SHARED      1
./include/mm/mman.h:#define MAP_PRIVATE     2
./include/mm/mman.h:#define MAP_TYPE        3     /* mask for above types */
./include/mm/mman.h:/* Mapping flags.
./include/mm/mman.h:#define MAP_FIXED       4
./include/mm/mman.h:#define MAP_ANON        8
./include/mm/mmobj.h:struct pframe;
./include/mm/mmobj.h:typedef struct mmobj_ops mmobj_ops_t;
./include/mm/mmobj.h:typedef struct mmobj {
./include/mm/mmobj.h:        int                 mmo_refcount;   /* mmo_refcount >= mmo_nrespages >= 0 */
./include/mm/mmobj.h:         * Members maintained by the pframe module; only the pframe module may
./include/mm/mmobj.h:         * modify these, but others may read/access them:
./include/mm/mmobj.h:         * For shadow objects, the mmo_bottom_obj member of the union should point
./include/mm/mmobj.h:         * mmo_vmas member of the union, should be a list of all vm_areas that
./include/mm/mmobj.h:         * have this object at the bottom of their tree of mmobjs.
./include/mm/mmobj.h:         * Note to self: field not used by mmobj code at all.. used
./include/mm/mmobj.h:         * externally by vm code to stack anonymous objects on top of other
./include/mm/mmobj.h:        /* Add a reference to 'o'.
./include/mm/mmobj.h:        void (*ref)(mmobj_t *o);
./include/mm/mmobj.h:        /* Drop a reference to 'o'.
./include/mm/mmobj.h:        /* Finds the correct page frame from a high-level perspective
./include/mm/mmobj.h:         * for performing the given operation on an area backed by
./include/mm/mmobj.h:         * the given pagenum of the given object. If "forwrite" is
./include/mm/mmobj.h:         * specified then the pframe should be suitable for writing;
./include/mm/mmobj.h:         * Most objects will simply return a page from their
./include/mm/mmobj.h:         * own list of pages, but objects such as shadow objects
./include/mm/mmobj.h:         * may need to perform more complicated operations to find
./include/mm/mmobj.h:        int (*lookuppage)(mmobj_t *o, uint32_t pagenum, int forwrite, struct pframe **pf);
./include/mm/mmobj.h:        /* Fill the page frame starting at address vp->vp_paddr with the
./include/mm/mmobj.h:         * contents of the page identified by vp->vp_obj and vp->vp_pagenum.
./include/mm/mmobj.h:        int (*fillpage)(mmobj_t *o, struct pframe *pf);
./include/mm/mmobj.h:         * Perform any necessary actions that must take place in order for it
./include/mm/mmobj.h:         * if this page corresponds to a sparse block of a file that belongs to
./include/mm/mmobj.h:         * an S5 filesystem, it would be necessary/desirable to allocate a
./include/mm/mmobj.h:         * block in the fs before allowing a write to the block to proceed).
./include/mm/mmobj.h:        int (*dirtypage)(mmobj_t *o, struct pframe *pf);
./include/mm/mmobj.h:         * Write the contents of the page frame starting at address
./include/mm/mmobj.h:         * vp->vp_paddr to the page identified by vp->vp_obj and
./include/mm/mmobj.h:        int (*cleanpage)(mmobj_t *o, struct pframe *pf);
./include/mm/mmobj.h: * Since by default the object is initialized as not a shadow object,
./include/mm/mmobj.h: * we intialize the mmo_vmas member of its union here
./include/mm/mmobj.h:        (o)->mmo_refcount = 0;
./include/mm/mmobj.h:#define mmobj_bottom_obj(o) \
./include/mm/mmobj.h:#define mmobj_bottom_vmas(o) \
./include/mm/page.h:/* This header file contains the functions for allocating
./include/mm/page.h: * and freeing page-aligned chunks of data which are a
./include/mm/page.h: * multiple of a page in size. These are the lowest level
./include/mm/page.h: * memory allocation functions. In general code should
./include/mm/page.h: * use the slab allocator functions in mm/alloc.h unless
./include/mm/page.h: * they require page-aligned buffers. */
./include/mm/page.h:#define PAGE_SHIFT         12
./include/mm/page.h:#define PAGE_SIZE          ((uint32_t)(1UL<<PAGE_SHIFT))
./include/mm/page.h:#define PAGE_MASK          (0xffffffff<<PAGE_SHIFT)
./include/mm/page.h:#define PAGE_ALIGN_DOWN(x) ((void*)(((uintptr_t)(x))&PAGE_MASK))
./include/mm/page.h:#define PAGE_ALIGN_UP(x)   ((void*)(((((uintptr_t)(x))-1)&PAGE_MASK)+PAGE_SIZE))
./include/mm/page.h:#define PAGE_OFFSET(x)     ((uintptr_t)(x)&~PAGE_MASK)
./include/mm/page.h:#define PN_TO_ADDR(x) ((void *)(((uint32_t)(x)) << PAGE_SHIFT))
./include/mm/page.h:#define ADDR_TO_PN(x) (((uint32_t)(x)) >> PAGE_SHIFT)
./include/mm/page.h:#define PAGE_ALIGNED(x) (0 == ((uintptr_t)(x)) % PAGE_SIZE)
./include/mm/page.h:#define PAGE_NSIZES  8
./include/mm/page.h:#define PAGE_SAME(addr1, addr2) (PAGE_ALIGN_DOWN(addr1) == PAGE_ALIGN_DOWN(addr2))
./include/mm/page.h: * only be called once for any given page (no overlaps). */
./include/mm/page.h:/* These functions allocate and free one page-aligned,
./include/mm/page.h: * page-sized block of memory. Values passed to
./include/mm/page.h: * page_free MUST have been returned by page_alloc
./include/mm/page.h: * call to page_free for each value returned by
./include/mm/page.h: * page_alloc. If the system is out of memory page_alloc
./include/mm/page.h:void  page_free(void *addr);
./include/mm/page.h:/* These functions allocate and free a page-aligned
./include/mm/page.h: * block of memory which are npages pages in length.
./include/mm/page.h: * A call to page_alloc_n will allocate a block, to free
./include/mm/page.h: * that block a call should be made to page_free_n with
./include/mm/page.h:void  page_free_n(void *start, uint32_t npages);
./include/mm/page.h:/* Returns the number of free pages remaining in the
./include/mm/page.h: * fail even if page_free_count() >= npages. */
./include/mm/page.h:uint32_t page_free_count();
./include/mm/pagetable.h:#define PD_PRESENT        0x001
./include/mm/pagetable.h:#define PD_WRITE          0x002
./include/mm/pagetable.h:#define PD_USER           0x004
./include/mm/pagetable.h:#define PD_WRITE_THROUGH  0x008
./include/mm/pagetable.h:#define PD_CACHE_DISABLED 0x010
./include/mm/pagetable.h:#define PD_ACCESSED       0x020
./include/mm/pagetable.h:#define PT_PRESENT        0x001
./include/mm/pagetable.h:#define PT_WRITE          0x002
./include/mm/pagetable.h:#define PT_USER           0x004
./include/mm/pagetable.h:#define PT_WRITE_THROUGH  0x008
./include/mm/pagetable.h:#define PT_CACHE_DISABLED 0x010
./include/mm/pagetable.h:#define PT_ACCESSED       0x020
./include/mm/pagetable.h:#define PT_DIRTY          0x040
./include/mm/pagetable.h:#define PT_SIZE           0x080
./include/mm/pagetable.h:#define PT_GLOBAL         0x100
./include/mm/pagetable.h:typedef uint32_t pte_t;
./include/mm/pagetable.h:typedef uint32_t pde_t;
./include/mm/pagetable.h:typedef struct pagedir pagedir_t;
./include/mm/pagetable.h: * calls to this function will return the same virtual address, thereby
./include/mm/pagetable.h:/* Permenantly maps the given number of physical pages, starting at the
./include/mm/pagetable.h: * address. Each call will return a different virtual address and the
./include/mm/pagetable.h: * memory will stay mapped forever. Note that there is an implementation
./include/mm/pagetable.h: * defined limit to the number of pages available and using too many
./include/mm/pagetable.h: * directory, in order to find the matching physical memory address it
./include/mm/pagetable.h: * otherwise this function's behavior is undefined */
./include/mm/pagetable.h: * given page directory. Creates a new page table if necessary and
./include/mm/pagetable.h: * Note that the TLB is not flushed by this function. */
./include/mm/pagetable.h:int pt_map(pagedir_t *pd, uintptr_t vaddr, uintptr_t paddr, uint32_t pdflags, uint32_t ptflags);
./include/mm/pagetable.h:/* Unmaps the page for the given virtual page from the given page
./include/mm/pagetable.h: * be page aligned. Note that the TLB is not flushed by this function. */
./include/mm/pagetable.h:/* Unmaps the given range of addresses [low, high). As with pt_unmap,
./include/mm/pagetable.h: * mappings for all kernel memory. If there is not enough memory
./include/mm/pagetable.h: * a page diretory does not affect the TLB, it is assumed that the
./include/mm/pagetable.h: * a page directory frees all page tables for user memory referenced
./include/mm/pagetable.h:/* Sets the page table in cr3 and performs other updates required by
./include/mm/pagetable.h: * it will be translated by the current page table before being
./include/mm/pagetable.h:/* Retreives the virtual address of the page directory currently in cr3. */
./include/mm/pframe.h:#define PF_BUSY                 0x01
./include/mm/pframe.h:#define PF_DIRTY                0x02
./include/mm/pframe.h:#define pframe_is_busy(pf)          ((pf)->pf_flags & PF_BUSY)
./include/mm/pframe.h:#define pframe_set_busy(pf)         do { (pf)->pf_flags |= PF_BUSY; } while (0)
./include/mm/pframe.h:#define pframe_clear_busy(pf)       do { (pf)->pf_flags &= ~PF_BUSY; } while (0)
./include/mm/pframe.h:#define pframe_is_dirty(pf)         ((pf)->pf_flags & PF_DIRTY)
./include/mm/pframe.h:#define pframe_set_dirty(pf)        do { (pf)->pf_flags |= PF_DIRTY; } while (0)
./include/mm/pframe.h:#define pframe_clear_dirty(pf)      do { (pf)->pf_flags &= ~PF_DIRTY; } while (0)
./include/mm/pframe.h:#define pframe_is_pinned(pf)        ((pf)->pf_pincount)
./include/mm/pframe.h:#define pframe_is_free(pf)          (!(pf)->pf_obj)
./include/mm/pframe.h:/* A pframe structure represents a page frame in physical memory available to the
./include/mm/pframe.h: * kernel. pframes are managed by mmobjs */
./include/mm/pframe.h:typedef struct pframe {
./include/mm/pframe.h:        /* Public read: (do not modify outside pframe.c) */
./include/mm/pframe.h:        /* Object and page number, which together uniquely identify the page */
./include/mm/pframe.h:        struct mmobj       *pf_obj;
./include/mm/pframe.h:        uint32_t            pf_pagenum;
./include/mm/pframe.h:        /*   The address of the page frame. Note that this is NOT a
./include/mm/pframe.h:        void               *pf_addr;
./include/mm/pframe.h:        uint8_t             pf_flags;    /* PF_DIRTY, PF_BUSY */
./include/mm/pframe.h:        ktqueue_t           pf_waitq;    /* wait on this if page is busy */
./include/mm/pframe.h:        int                 pf_pincount;
./include/mm/pframe.h:        list_link_t         pf_link;     /* link on {free,allocated,pinned}_list */
./include/mm/pframe.h:        list_link_t         pf_hlink;    /* link on hash chain of resident page hash */
./include/mm/pframe.h:        list_link_t         pf_olink;    /* link on object's list of resident pages */
./include/mm/pframe.h:} pframe_t;
./include/mm/pframe.h:void pframe_init(void);
./include/mm/pframe.h:void pframe_add_range(uint32_t startpfn, uint32_t endpfn);
./include/mm/pframe.h:void pframe_pageoutd_init(void);
./include/mm/pframe.h:void pframe_shutdown(void);
./include/mm/pframe.h:pframe_t *pframe_get_resident(struct mmobj *o, uint32_t pagenum);
./include/mm/pframe.h:int pframe_get(struct mmobj *o, uint32_t pagenum, pframe_t **result);
./include/mm/pframe.h:int pframe_lookup(struct mmobj *o, uint32_t pagenum, int forwrite, pframe_t **result);
./include/mm/pframe.h:void pframe_migrate(pframe_t *pf, mmobj_t *dest);
./include/mm/pframe.h:void pframe_pin(pframe_t *pf);
./include/mm/pframe.h:void pframe_unpin(pframe_t *pf);
./include/mm/pframe.h:int  pframe_dirty(pframe_t *pf);
./include/mm/pframe.h:int  pframe_clean(pframe_t *pf);
./include/mm/pframe.h:void pframe_free(pframe_t *pf);
./include/mm/pframe.h:void pframe_clean_all(void);
./include/mm/pframe.h:void pframe_remove_from_pts(pframe_t *pf);
./include/mm/phys.h:/* Returns the highest physical address of the range of usable
./include/mm/phys.h: * be the largest available continuous range of physical
./include/mm/phys.h: * addresses. This function should only be used during booting
./include/mm/phys.h: * while the first megabyte of memory is identity mapped,
./include/mm/phys.h: * otherwise its behavior is undefined. */
./include/mm/slab.h:/* Define SLAB_REDZONE to add top and bottom redzones to every object.
./include/mm/slab.h: * for memory pissing. */
./include/mm/slab.h:#define SLAB_REDZONE            0xdeadbeef
./include/mm/slab.h:/* Define SLAB_CHECK_FREE to add extra book keeping to make sure there
./include/mm/slab.h: * are no double frees. */
./include/mm/slab.h:#define SLAB_CHECK_FREE
./include/mm/slab.h: * The slab allocator. A "cache" is a store of objects; you create one by
./include/mm/slab.h: * specifying a constructor, destructor, and the size of an object. The
./include/mm/slab.h: * "alloc" function allocates one object, and the "free" function returns
./include/mm/slab.h: * it to the free list *without calling the destructor*. This lets you save
./include/mm/slab.h: * on destruction/construction calls; the idea is that every free object in
./include/mm/slab.h:typedef struct slab_allocator slab_allocator_t;
./include/mm/slab.h:void slab_obj_free(slab_allocator_t *allocator, void *obj);
./include/mm/tlb.h:/* Invalidates any entries from the TLB which contain
./include/mm/tlb.h: * mappings for the given virtual address. */
./include/mm/tlb.h:static inline void tlb_flush(uintptr_t vaddr)
./include/mm/tlb.h:/* Invalidates any entries for the count virtual addresses
./include/mm/tlb.h: * starting at vaddr from the TLB. If this range is very
./include/mm/tlb.h: * large it may be more efficient to call tlb_flush_all
./include/mm/tlb.h:static inline void tlb_flush_range(uintptr_t vaddr, uint32_t count)
./include/mm/tlb.h:        for (i = 0; i < count; ++i, vaddr += PAGE_SIZE) {
./include/mm/tlb.h:                tlb_flush(vaddr);
./include/mm/tlb.h:static inline void tlb_flush_all()
./include/proc/context.h: * The function pointer to be implemented by functions which are entry
./include/proc/context.h: * points for new threads.
./include/proc/context.h:typedef void *(*context_func_t)(int, void *);
./include/proc/context.h:typedef struct context {
./include/proc/context.h:        uint32_t   c_ebp; /* frame pointer (EBP) */
./include/proc/context.h:        pagedir_t *c_pdptr; /* pointer to the page directory for this proc */
./include/proc/context.h: * will execute func(arg1,arg2). When the thread returns from func it
./include/proc/context.h: * @param func the function which will begin executing when this
./include/proc/context.h: * context is first made active
./include/proc/context.h: * @param arg1 the first argument to func
./include/proc/context.h: * @param arg2 the second argument to func
./include/proc/context.h: * @param kstacksz the size of the kernel stack
./include/proc/context.h:void context_setup(context_t *c, context_func_t func, int arg1, void *arg2,
./include/proc/context.h: * this mainly for the initial context.
./include/proc/context.h: * Save the current state of the machine into the old context, and begin
./include/proc/context.h: * @param oldc the context to switch from
./include/proc/kmutex.h:typedef struct kmutex {
./include/proc/kmutex.h: * Initializes the fields of the specified kmutex_t.
./include/proc/kmutex.h: * Locks the specified mutex.
./include/proc/kmutex.h: * Note: This function may block.
./include/proc/kmutex.h: * Locks the specified mutex, but puts the current thread into a
./include/proc/kmutex.h: * cancellable sleep if the function blocks.
./include/proc/kmutex.h: * Note: This function may block.
./include/proc/kmutex.h: * @return 0 if the current thread now holds the mutex and -EINTR if
./include/proc/kmutex.h: * Unlocks the specified mutex.
./include/proc/kthread.h:typedef context_func_t kthread_func_t;
./include/proc/kthread.h:typedef struct kthread {
./include/proc/kthread.h:        int             kt_errno;       /* error no. of most recent syscall */
./include/proc/kthread.h:        int             kt_cancelled;   /* 1 if this thread has been cancelled */
./include/proc/kthread.h:                                        /* qlink is not a list, its the link of this thread in wchan ktqueue */
./include/proc/kthread.h:#ifdef __MTP__
./include/proc/kthread.h:        int             kt_detached;    /* if the thread has been detached */
./include/proc/kthread.h:#endif
./include/proc/kthread.h:#define KT_NO_STATE             0       /* illegal state */
./include/proc/kthread.h:#define KT_RUN                  1       /* currently running, or on runq */
./include/proc/kthread.h:#define KT_SLEEP                2       /* blocked for an indefinite amount of time */
./include/proc/kthread.h:#define KT_SLEEP_CANCELLABLE    3       /* blocked, but this sleep can be cancelled */
./include/proc/kthread.h:#define KT_EXITED               4       /* has exited, waiting to be joined */
./include/proc/kthread.h: * @param func the function that will be called when the newly created
./include/proc/kthread.h: * @param arg1 the first argument to func
./include/proc/kthread.h: * @param arg2 the second argument to func
./include/proc/kthread.h:kthread_t *kthread_create(struct proc *p, kthread_func_t func, long arg1, void *arg2);
./include/proc/kthread.h: * @param t the thread to free
./include/proc/kthread.h: * @param retval the return value for the thread
./include/proc/kthread.h: * @param retval the return value for the thread
./include/proc/kthread.h: * Allocates a new thread that is a copy of a specified thread.
./include/proc/kthread.h: * @return a cloned version of thr
./include/proc/kthread.h:#ifdef __MTP__
./include/proc/kthread.h: * Wait for the termination of another thread.
./include/proc/kthread.h: * @param kthr the thread to wait for
./include/proc/kthread.h: * @param retval if retval is not NULL, the return value for kthr is
./include/proc/kthread.h:#endif
./include/proc/proc.h:#include "config.h"
./include/proc/proc.h:#define PROC_MAX_COUNT  65536
./include/proc/proc.h:#define PROC_NAME_LEN   256
./include/proc/proc.h:typedef struct proc {
./include/proc/proc.h:                                         /* p_children is the head of the list of children process of this process */
./include/proc/proc.h:        ktqueue_t       p_wait;          /* queue for wait(2) */
./include/proc/proc.h:        list_link_t     p_list_link;     /* link on the list of all processes */
./include/proc/proc.h:        list_link_t     p_child_link;    /* link on proc list of children */
./include/proc/proc.h:                                         /* p_child_link is the link of this process in its parents list of child process */
./include/proc/proc.h:        struct file    *p_files[NFILES]; /* open files */
./include/proc/proc.h:        void           *p_start_brk;     /* initial value of process break */
./include/proc/proc.h:        struct vmmap   *p_vmmap;         /* list of areas mapped into
./include/proc/proc.h:#define PROC_RUNNING    1       /* has running threads */
./include/proc/proc.h:#define PROC_DEAD       2       /* has already exited, hasn't been wait'ed */
./include/proc/proc.h:/* Special PIDs for Kernel Deamons */
./include/proc/proc.h:#define PID_IDLE     0
./include/proc/proc.h:#define PID_INIT     1
./include/proc/proc.h: * This function allocates and initializes a new process.
./include/proc/proc.h: * Finds the process with the specified PID.
./include/proc/proc.h: * @param pid the PID of the process to find
./include/proc/proc.h: * @return a pointer to the process with PID pid, or NULL if there is
./include/proc/proc.h: * Returns the list of running processes.
./include/proc/proc.h: * @return the list of running processes
./include/proc/proc.h: * Stops another process from running again by cancelling all its
./include/proc/proc.h: * Kill every process except for the idle process.
./include/proc/proc.h: * @param retval the return value for the current thread
./include/proc/proc.h: * This function implements the _exit(2) system call.
./include/proc/proc.h: * @param status the exit status of the process
./include/proc/proc.h: * This function implements the waitpid(2) system call.
./include/proc/proc.h: * @param status used to return the exit status of the child
./include/proc/proc.h: * @return the pid of the child process which was cleaned up, or
./include/proc/proc.h: * -ECHILD if there are no children of this process
./include/proc/proc.h: * This function implements the fork(2) system call.
./include/proc/proc.h: * @param regs the register state at the time of the system call
./include/proc/proc.h:int do_fork(struct regs *regs);
./include/proc/proc.h: * Provides detailed debug information about a given process.
./include/proc/proc.h: * @param buf buffer to write to
./include/proc/proc.h: * @param osize size of the buffer
./include/proc/proc.h: * @return the remaining size of the buffer
./include/proc/proc.h:size_t proc_info(const void *arg, char *buf, size_t osize);
./include/proc/proc.h: * Provides debug information overview of all processes.
./include/proc/proc.h: * @param buf buffer to write to
./include/proc/proc.h: * @param osize size of the buffer
./include/proc/proc.h: * @return the remaining size of the buffer
./include/proc/proc.h:size_t proc_list_info(const void *arg, char *buf, size_t osize);
./include/proc/sched.h:typedef struct ktqueue {
./include/proc/sched.h: * Returns true if the queue is empty.
./include/proc/sched.h: * @return true if the queue is empty
./include/proc/sched.h: * @return -EINTR if the thread was cancelled and 0 otherwise
./include/proc/sched.h: * Wakes a single thread from sleep if there are any waiting on the
./include/proc/sched.h: * @param q the q to wakeup a thread from
./include/proc/sched.h: * @return NULL if q is empty and a thread waiting on the q otherwise
./include/proc/sched.h: * @param q the queue to wake up threads from
./include/proc/sched.h: * Cancel the given thread from the queue it sleeps on.
./include/proc/sched.h: * @param the thread to cancel sleep from
./include/util/bits.h:bit_flip(void *addr, uintptr_t bit)
./include/util/bits.h:        *map ^= (uint32_t)(1 << (bit & 0x1f));
./include/util/bits.h:        return (*map & (1 << (bit & 0x1f)));
./include/util/debug.h: * These color definitions are from the ANSI specs.
./include/util/debug.h: * Do a web search for ANSI color codes to find out
./include/util/debug.h: * more funky shit like this
./include/util/debug.h:#define _NORMAL_    "\x1b[0m"
./include/util/debug.h:#define _BLACK_     "\x1b[30;47m"
./include/util/debug.h:#define _RED_       "\x1b[31;40m"
./include/util/debug.h:#define _GREEN_     "\x1b[32;40m"
./include/util/debug.h:#define _YELLOW_    "\x1b[33;40m"
./include/util/debug.h:#define _BLUE_      "\x1b[34;40m"
./include/util/debug.h:#define _MAGENTA_   "\x1b[35;40m"
./include/util/debug.h:#define _CYAN_      "\x1b[36;40m"
./include/util/debug.h:#define _WHITE_     "\x1b[37;40m"
./include/util/debug.h:#define _BRED_      "\x1b[1;31;40m"
./include/util/debug.h:#define _BGREEN_    "\x1b[1;32;40m"
./include/util/debug.h:#define _BYELLOW_   "\x1b[1;33;40m"
./include/util/debug.h:#define _BBLUE_     "\x1b[1;34;40m"
./include/util/debug.h:#define _BMAGENTA_  "\x1b[1;35;40m"
./include/util/debug.h:#define _BCYAN_     "\x1b[1;36;40m"
./include/util/debug.h:#define _BWHITE_    "\x1b[1;37;40m"
./include/util/debug.h:#define DBG_MODE(x)     (1ULL << (x))
./include/util/debug.h:/* These defines list all of the possible debugging
./include/util/debug.h: * types. They are flags, so make sure to use the
./include/util/debug.h:#define DBG_ALL         (~0ULL)         /* umm, "verbose"               */
./include/util/debug.h:#define DBG_CORE        DBG_MODE(0)     /* core boot code               */
./include/util/debug.h:#define DBG_MM          DBG_MODE(1)     /* memory management            */
./include/util/debug.h:#define DBG_INIT        DBG_MODE(2)     /* boot/init code               */
./include/util/debug.h:#define DBG_SCHED       DBG_MODE(3)     /* swtch, scheduling            */
./include/util/debug.h:#define DBG_DISK        DBG_MODE(4)     /* disk driver                  */
./include/util/debug.h:#define DBG_TEMP        DBG_MODE(5)     /* for resolving temporary problems */
./include/util/debug.h:#define DBG_KMALLOC     DBG_MODE(6)     /* kmalloc, kmem_cache_alloc    */
./include/util/debug.h:#define DBG_PAGEALLOC   DBG_MODE(7)     /* page_alloc, etc.             */
./include/util/debug.h:#define DBG_INTR        DBG_MODE(8)     /* misc. trap/interrupt         */
./include/util/debug.h:#define DBG_TERM        DBG_MODE(9)     /* the terminal device          */
./include/util/debug.h:#define DBG_FORK        DBG_MODE(10)    /* fork(2)                      */
./include/util/debug.h:#define DBG_PROC        DBG_MODE(11)    /* process stuff                */
./include/util/debug.h:#define DBG_VNREF       DBG_MODE(12)    /* vnode reference counts       */
./include/util/debug.h:#define DBG_PFRAME      DBG_MODE(13)    /* pframe subsys                */
./include/util/debug.h:#define DBG_ERROR       DBG_MODE(14)    /* error conditions             */
./include/util/debug.h:#define DBG_SYSCALL     DBG_MODE(15)    /* system calls                 */
./include/util/debug.h:#define DBG_FREF        DBG_MODE(16)    /* file reference counts        */
./include/util/debug.h:#define DBG_PGTBL       DBG_MODE(17)    /* page table manipulation      */
./include/util/debug.h:#define DBG_BRK         DBG_MODE(18)    /* process break; user memory alloc */
./include/util/debug.h:#define DBG_EXEC        DBG_MODE(19)    /* new process exec             */
./include/util/debug.h:#define DBG_VFS         DBG_MODE(20)    /* vfs                          */
./include/util/debug.h:#define DBG_S5FS        DBG_MODE(21)    /* system V file system         */
./include/util/debug.h:#define DBG_KB          DBG_MODE(22)    /* keyboard                     */
./include/util/debug.h:#define DBG_THR         DBG_MODE(23)    /* thread stuff                 */
./include/util/debug.h:#define DBG_PRINT       DBG_MODE(24)    /* printdbg.c                   */
./include/util/debug.h:#define DBG_OSYSCALL    DBG_MODE(25)    /* other system calls           */
./include/util/debug.h:#define DBG_VM          DBG_MODE(28)    /* VM                           */
./include/util/debug.h:#define DBG_TEST        DBG_MODE(30)    /* for testing code             */
./include/util/debug.h:#define DBG_TESTPASS    DBG_MODE(31)    /* for testing code             */
./include/util/debug.h:#define DBG_TESTFAIL    DBG_MODE(32)    /* for testing code             */
./include/util/debug.h:#define DBG_MEMDEV      DBG_MODE(33)    /* For memory devices ("null" and "zero") */
./include/util/debug.h:#define DBG_ANON        DBG_MODE(34)    /* anonymous vm objects         */
./include/util/debug.h:#define DBG_VMMAP       DBG_MODE(35)    /* vm area mappings             */
./include/util/debug.h:#define DBG_ELF         DBG_MODE(37)    /* elf loader                   */
./include/util/debug.h:#define DBG_USER        DBG_MODE(38)    /* user land                    */
./include/util/debug.h:#define DBG_DEFAULT     DBG_ERROR       /* default modes, 0 for none    */
./include/util/debug.h:/* This defines the name that is used in the
./include/util/debug.h: * debugging type, along with the color of the debug type */
./include/util/debug.h:/* NOTE that there is an order to these objects - the color chosen for a
./include/util/debug.h: * debug statement with multiple DBG specifiers will be the first matching
./include/util/debug.h:/* Note that rearranging the table will affect results, and may be beneficial
./include/util/debug.h:#define DBG_TAB                                 \
./include/util/debug.h:        {"testfail", DBG_TESTFAIL, _RED_ },     \
./include/util/debug.h:        {"vfs", DBG_VFS, _WHITE_ },             \
./include/util/debug.h:        {"fref", DBG_FREF, _MAGENTA_ },         \
./include/util/debug.h:        {"vnref", DBG_VNREF, _CYAN_ },          \
./include/util/debug.h:        {"s5fs", DBG_S5FS, _BRED_ },            \
./include/util/debug.h:        {"pframe", DBG_PFRAME, _BMAGENTA_ },    \
./include/util/debug.h:        {"fork", DBG_FORK, _BYELLOW_ },         \
./include/util/debug.h:        {"elf", DBG_ELF, _BGREEN_ },            \
./include/util/debug.h:        /* Also note that the color specified here is effectively the "default" */ \
./include/util/debug.h:/* A common interface for functions which provide human-readable information about
./include/util/debug.h: * some data structure. Functions implementing this interface should fill buf with
./include/util/debug.h: * number of characters writen. If there is not enough space in buf to write all
./include/util/debug.h: * information then only size characters will be writen and size will be returned.
./include/util/debug.h: * The returned string will be null terminated regardless of its length. */
./include/util/debug.h:typedef size_t (*dbg_infofunc_t)(const void *data, char *buf, size_t size);
./include/util/debug.h:#define DBG_BUFFER_SIZE (PAGE_SIZE)
./include/util/debug.h:void dbg_print(char *fmt, ...) __attribute__((format(printf, 1, 2)));
./include/util/debug.h:void dbg_printinfo(dbg_infofunc_t func, const void *data);
./include/util/debug.h:#ifndef NDEBUG
./include/util/debug.h:#define dbg(mode, ...)                                          \
./include/util/debug.h:                if (dbg_active(mode)) {                         \
./include/util/debug.h:                        dbg_print("%s:%d %s(): ",__FILE__, __LINE__, __func__); \
./include/util/debug.h:#define dbgq(mode, ...)                                         \
./include/util/debug.h:                if (dbg_active(mode)) {                         \
./include/util/debug.h:#define dbginfo(mode,func,data)                                 \
./include/util/debug.h:                if (dbg_active(mode)) {                         \
./include/util/debug.h:                        dbg_printinfo(func, data);              \
./include/util/debug.h:#define dbg_active(mode) (dbg_modes & (mode))
./include/util/debug.h:#define dbg(mode, arg)
./include/util/debug.h:#define dbg_active(mode) 0
./include/util/debug.h:#define dbg_add_mode(mode)
./include/util/debug.h:#define dbg_add_modes(modes)
./include/util/debug.h:#endif
./include/util/debug.h:void dbg_panic(const char *file, int line, const char *func, const char *fmt, ...) __attribute__((format(printf, 4, 5)));
./include/util/debug.h:#define panic(fmt, args...) dbg_panic(__FILE__, __LINE__, __func__, (fmt), ## args)
./include/util/debug.h:#ifndef NDEBUG
./include/util/debug.h:#define KASSERT(x) do { if (!(x)) panic("assertion failed: %s", #x); } while(0)
./include/util/debug.h:#define KASSERT(x)
./include/util/debug.h:#endif
./include/util/delay.h:/* Approximate numbers taken from various points in Linux kernel */
./include/util/delay.h:#define LOOPS_PER_JIFFY (1 << 12)
./include/util/delay.h:#define HZ 100 /* Found this in a random place in the kernel */
./include/util/delay.h: *      Precise Delay Loops for i386
./include/util/delay.h: *      Copyright (C) 1997 Martin Mares <mj@atrey.karlin.mff.cuni.cz>
./include/util/delay.h: *      The __delay function must _NOT_ be inlined as its execution time
./include/util/delay.h:                "	jz 3f		\n"
./include/util/delay.h:                "	jmp 1f		\n"
./include/util/delay.h:                "1:	jmp 2f		\n"
./include/util/delay.h:#define udelay(n) (__builtin_constant_p(n) ? \
./include/util/delay.h:#define ndelay(n) (__builtin_constant_p(n) ? \
./include/util/gdb.h:#define GDB_DEFINE_HOOK(name, ...) \
./include/util/gdb.h:#define GDB_CALL_HOOK(name, ...) \
./include/util/init.h:#define init_func(func)                         \
./include/util/init.h:                ".long " #func "\n\t"           \
./include/util/init.h:                ".string \"" #func "\"\n\t"     \
./include/util/init.h:#define init_depends(name)                      \
./include/util/init.h:typedef void (*init_func_t)();
./include/util/list.h: * list_t is the head of the list.
./include/util/list.h: * All of the list functions take pointers to list_t and list_link_t
./include/util/list.h: * types, unless otherwise specified.
./include/util/list.h: * list_empty(list) returns 1 iff the list is empty.
./include/util/list.h: * Insertion functions.
./include/util/list.h: *   list_insert_head(list, link) inserts at the front of the list.
./include/util/list.h: *   list_insert_tail(list, link) inserts at the end of the list.
./include/util/list.h: *   list_insert_before(olink, nlink) inserts nlink before olink in list.
./include/util/list.h: * Removal functions.
./include/util/list.h: * The following functions should only be called on non-empty lists.
./include/util/list.h: *   list_remove(link) removes a specific element from the list.
./include/util/list.h: *   list_remove_head(list) removes the first element.
./include/util/list.h: * Given a list_link_t* and the name of the type of structure which contains
./include/util/list.h: * the list_link_t and the name of the member corresponding to the list_link_t,
./include/util/list.h: * returns a pointer (of type "type*") to the item.
./include/util/list.h: *    for (link = list->l_next;
./include/util/list.h: * Or, use the macros, which will work even if you list_remove() the
./include/util/list.h:typedef struct list {
./include/util/list.h:#define list_link_init(link)                                            \
./include/util/list.h:#define list_link_is_linked(link)                                       \
./include/util/list.h:#define list_init(list)                                                 \
./include/util/list.h:#define list_empty(list)                                                \
./include/util/list.h:#define list_insert_before(old, new)                                    \
./include/util/list.h:#define list_insert_head(list, link)                                    \
./include/util/list.h:        list_insert_before((list)->l_next, link)
./include/util/list.h:#define list_insert_tail(list, link)                                    \
./include/util/list.h:        list_insert_before(list, link)
./include/util/list.h:#define list_remove(link)                                               \
./include/util/list.h:#define list_remove_head(list)                                          \
./include/util/list.h:#define list_remove_tail(list)                                          \
./include/util/list.h:#define list_item(link, type, member)                                   \
./include/util/list.h:        (type*)((char*)(link) - offsetof(type, member))
./include/util/list.h:#define list_head(list, type, member)                                   \
./include/util/list.h:#define list_tail(list, type, member)                                   \
./include/util/list.h:#define list_iterate_begin(list, var, type, member)                     \
./include/util/list.h:                for (__link = (list)->l_next;                           \
./include/util/list.h:#define list_iterate_reverse(list, var, type, member)                   \
./include/util/list.h:                for (__link = (list)->l_prev;                           \
./include/util/list.h:#define list_iterate_end()                                              \
./include/util/printf.h:/* -*-  Mode:C; c-basic-offset:4; tab-width:4 -*-
./include/util/printf.h: * (C) 2003 - Rolf Neugebauer - Intel Research Cambridge
./include/util/printf.h: *      Author: Rolf Neugebauer (neugebar@dcs.gla.ac.uk)
./include/util/printf.h: * Description: Random useful library functions, contains some freebsd stuff
./include/util/printf.h: * $Id: printf.h,v 1.1 2012/10/10 20:08:40 william Exp $
./include/util/printf.h: *      The Regents of the University of California.  All rights reserved.
./include/util/printf.h: * Redistribution and use in source and binary forms, with or without
./include/util/printf.h: * modification, are permitted provided that the following conditions
./include/util/printf.h: * 1. Redistributions of source code must retain the above copyright
./include/util/printf.h: *    notice, this list of conditions and the following disclaimer.
./include/util/printf.h: * 2. Redistributions in binary form must reproduce the above copyright
./include/util/printf.h: *    notice, this list of conditions and the following disclaimer in the
./include/util/printf.h: * 3. All advertising materials mentioning features or use of this software
./include/util/printf.h: *    must display the following acknowledgement:
./include/util/printf.h: *      This product includes software developed by the University of
./include/util/printf.h: *      California, Berkeley and its contributors.
./include/util/printf.h: * 4. Neither the name of the University nor the names of its contributors
./include/util/printf.h: *    may be used to endorse or promote products derived from this software
./include/util/printf.h: *    without specific prior written permission.
./include/util/printf.h:int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
./include/util/printf.h:int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
./include/util/printf.h:int snprintf(char *buf, size_t size, const char *fmt, ...);
./include/util/printf.h:int scnprintf(char *buf, size_t size, const char *fmt, ...);
./include/util/printf.h:int vsprintf(char *buf, const char *fmt, va_list args);
./include/util/printf.h:int sprintf(char *buf, const char *fmt, ...);
./include/util/printf.h:/* A variation on printf designed to be used in debug info functions.
./include/util/printf.h: * The function takes in a pointer to the address of a string buffer
./include/util/printf.h: * and a pointer to the size of the buffer. The buffer address pointed
./include/util/printf.h: * end of the new string. The size is decremented by the number of
./include/util/printf.h: * characters writen, not including the null character. The function
./include/util/printf.h: * returns the number of characters left in the buffer (after taking
./include/util/printf.h:int iprintf(char **str, size_t *size, char *fmt, ...) __attribute__((format(printf, 3, 4)));
./include/util/printf.h:int vsscanf(const char *buf, const char *fmt, va_list args);
./include/util/printf.h:int sscanf(const char *buf, const char *fmt, ...);
./include/util/string.h:/* -*-  Mode:C; c-basic-offset:4; tab-width:4 -*-
./include/util/string.h: * (C) 2003 - Rolf Neugebauer - Intel Research Cambridge
./include/util/string.h: *      Author: Rolf Neugebauer (neugebar@dcs.gla.ac.uk)
./include/util/string.h: * Description: Random useful library functions, contains some freebsd stuff
./include/util/string.h: *      The Regents of the University of California.  All rights reserved.
./include/util/string.h: * Redistribution and use in source and binary forms, with or without
./include/util/string.h: * modification, are permitted provided that the following conditions
./include/util/string.h: * 1. Redistributions of source code must retain the above copyright
./include/util/string.h: *    notice, this list of conditions and the following disclaimer.
./include/util/string.h: * 2. Redistributions in binary form must reproduce the above copyright
./include/util/string.h: *    notice, this list of conditions and the following disclaimer in the
./include/util/string.h: * 3. All advertising materials mentioning features or use of this software
./include/util/string.h: *    must display the following acknowledgement:
./include/util/string.h: *      This product includes software developed by the University of
./include/util/string.h: *      California, Berkeley and its contributors.
./include/util/string.h: * 4. Neither the name of the University nor the names of its contributors
./include/util/string.h: *    may be used to endorse or promote products derived from this software
./include/util/string.h: *    without specific prior written permission.
./include/util/string.h:/* return string-representation of an errno */
./include/vm/mmap.h:int do_mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off, void **ret);
./include/vm/pagefault.h:#define FAULT_PRESENT  0x01
./include/vm/pagefault.h:#define FAULT_WRITE    0x02
./include/vm/pagefault.h:#define FAULT_USER     0x04
./include/vm/pagefault.h:#define FAULT_RESERVED 0x08
./include/vm/pagefault.h:#define FAULT_EXEC     0x10
./include/vm/pagefault.h:void handle_pagefault(uintptr_t vaddr, uint32_t cause);
./include/vm/vmmap.h:#define VMMAP_DIR_LOHI 1
./include/vm/vmmap.h:#define VMMAP_DIR_HILO 2
./include/vm/vmmap.h:typedef struct vmmap {
./include/vm/vmmap.h:/* make sure you understand why mapping boundaries are in terms of frame
./include/vm/vmmap.h:typedef struct vmarea {
./include/vm/vmmap.h:        uint32_t       vma_start;    /* [starting vfn, */
./include/vm/vmmap.h:        uint32_t       vma_end;      /*  ending vfn) */
./include/vm/vmmap.h:        uint32_t       vma_off;      /* offset from beginning of vma_obj in pages */
./include/vm/vmmap.h:        int            vma_flags;    /* either MAP_SHARED or MAP_PRIVATE */
./include/vm/vmmap.h:        struct mmobj  *vma_obj;      /* the vm object to read pages from */
./include/vm/vmmap.h:        list_link_t    vma_olink;    /* link on the list of all vm_areas
./include/vm/vmmap.h:                                      * bottom of their chain */
./include/vm/vmmap.h:vmarea_t *vmmap_lookup(vmmap_t *map, uint32_t vfn);
./include/vm/vmmap.h:int vmmap_map(vmmap_t *map, struct vnode *file, uint32_t lopage, uint32_t npages, int prot, int flags, off_t off, int dir, vmarea_t **new);
./include/vm/vmmap.h:int vmmap_is_range_empty(vmmap_t *map, uint32_t startvfn, uint32_t npages);
./include/vm/vmmap.h:int vmmap_find_range(vmmap_t *map, uint32_t npages, int dir);
./include/vm/vmmap.h:int vmmap_read(vmmap_t *map, const void *vaddr, void *buf, size_t count);
./include/vm/vmmap.h:int vmmap_write(vmmap_t *map, void *vaddr, const void *buf, size_t count);
./include/vm/vmmap.h:size_t vmmap_mapping_info(const void *map, char *buf, size_t size);
./test/kshell/command.h:typedef struct kshell_command {
./test/kshell/command.h:        kshell_cmd_func_t kc_cmd_func;
./test/kshell/command.h:                                        kshell_cmd_func_t cmd_func,
./test/kshell/commands.h:#define KSHELL_CMD(name) \
./test/kshell/commands.h:#ifdef __VFS__
./test/kshell/commands.h:#endif
./test/kshell/priv.h:#define dprintf(x, args...) dbg(DBG_TEST, x, ## args)
./test/kshell/priv.h:#define KSH_BUF_SIZE 1024 /* This really just needs to be as large as
./test/kshell/priv.h:* the line discipline buffer */
./test/kshell/priv.h:#define KSH_CMD_NAME_LEN 16
./test/kshell/priv.h:#define KSH_MAX_ARGS 128
./test/kshell/priv.h:#define KSH_DESC_LEN 64
./test/kshell/priv.h:        /* If we have a filesystem, we can write to the file
./test/kshell/priv.h:#ifdef __VFS__
./test/kshell/priv.h:        int ksh_fd;
./test/kshell/priv.h:        /* Used for redirection */
./test/kshell/priv.h:        int ksh_out_fd;
./test/kshell/priv.h:        int ksh_in_fd;
./test/kshell/priv.h:#endif
./test/kshell/priv.h: * Searches for a shell command with a specified name.
./test/kshell/priv.h: * @param name name of the command to search for
./test/kshell/priv.h: * @param namelen length of name
./test/kshell/priv.h: * @return the command, if it exists, or NULL
./test/kshell/tokenizer.h:typedef enum kshell_token_type {
./test/kshell/tokenizer.h:        KTT_MAX /* Number of token types */
./test/kshell/tokenizer.h:typedef struct kshell_token {
./test/kshell/tokenizer.h: * Note: To find multiple tokens from the same line, you increment the
./test/kshell/tokenizer.h: * line pointer by the number of bytes processed before the next call
./test/kshell/tokenizer.h: * @param token out parameter containing the next token found
./test/kshell/tokenizer.h: * @return 0 if no more tokens, otherwise, number of bytes processed
